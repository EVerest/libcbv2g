/* SPDX-License-Identifier: Apache-2.0 */
/*
 * Copyright (C) 2022 - 2023 chargebyte GmbH
 * Copyright (C) 2022 - 2023 Contributors to EVerest
 */

/*****************************************************
 *
 * @author
 * @version
 *
 * The Code is generated! Changes may be overwritten.
 *
 *****************************************************/

/**
  * @file iso20_WPT_Encoder.c
  * @brief Description goes here
  *
  **/
#include <stdint.h>

#include "cbv2g/common/exi_basetypes.h"
#include "cbv2g/common/exi_basetypes_encoder.h"
#include "cbv2g/common/exi_error_codes.h"
#include "cbv2g/common/exi_header.h"
#include "cbv2g/iso_20/iso20_WPT_Datatypes.h"
#include "cbv2g/iso_20/iso20_WPT_Encoder.h"



static int encode_iso20_wpt_TransformType(exi_bitstream_t* stream, const struct iso20_wpt_TransformType* TransformType);
static int encode_iso20_wpt_TransformsType(exi_bitstream_t* stream, const struct iso20_wpt_TransformsType* TransformsType);
static int encode_iso20_wpt_DSAKeyValueType(exi_bitstream_t* stream, const struct iso20_wpt_DSAKeyValueType* DSAKeyValueType);
static int encode_iso20_wpt_X509IssuerSerialType(exi_bitstream_t* stream, const struct iso20_wpt_X509IssuerSerialType* X509IssuerSerialType);
static int encode_iso20_wpt_DigestMethodType(exi_bitstream_t* stream, const struct iso20_wpt_DigestMethodType* DigestMethodType);
static int encode_iso20_wpt_RSAKeyValueType(exi_bitstream_t* stream, const struct iso20_wpt_RSAKeyValueType* RSAKeyValueType);
static int encode_iso20_wpt_CanonicalizationMethodType(exi_bitstream_t* stream, const struct iso20_wpt_CanonicalizationMethodType* CanonicalizationMethodType);
static int encode_iso20_wpt_WPT_TxRxPulseOrderType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_TxRxPulseOrderType* WPT_TxRxPulseOrderType);
static int encode_iso20_wpt_SignatureMethodType(exi_bitstream_t* stream, const struct iso20_wpt_SignatureMethodType* SignatureMethodType);
static int encode_iso20_wpt_KeyValueType(exi_bitstream_t* stream, const struct iso20_wpt_KeyValueType* KeyValueType);
static int encode_iso20_wpt_WPT_CoordinateXYZType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_CoordinateXYZType* WPT_CoordinateXYZType);
static int encode_iso20_wpt_ReferenceType(exi_bitstream_t* stream, const struct iso20_wpt_ReferenceType* ReferenceType);
static int encode_iso20_wpt_RetrievalMethodType(exi_bitstream_t* stream, const struct iso20_wpt_RetrievalMethodType* RetrievalMethodType);
static int encode_iso20_wpt_X509DataType(exi_bitstream_t* stream, const struct iso20_wpt_X509DataType* X509DataType);
static int encode_iso20_wpt_PGPDataType(exi_bitstream_t* stream, const struct iso20_wpt_PGPDataType* PGPDataType);
static int encode_iso20_wpt_SPKIDataType(exi_bitstream_t* stream, const struct iso20_wpt_SPKIDataType* SPKIDataType);
static int encode_iso20_wpt_SignedInfoType(exi_bitstream_t* stream, const struct iso20_wpt_SignedInfoType* SignedInfoType);
static int encode_iso20_wpt_SignatureValueType(exi_bitstream_t* stream, const struct iso20_wpt_SignatureValueType* SignatureValueType);
static int encode_iso20_wpt_RationalNumberType(exi_bitstream_t* stream, const struct iso20_wpt_RationalNumberType* RationalNumberType);
static int encode_iso20_wpt_WPT_LF_RxRSSIType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxRSSIType* WPT_LF_RxRSSIType);
static int encode_iso20_wpt_WPT_LF_RxRSSIListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxRSSIListType* WPT_LF_RxRSSIListType);
static int encode_iso20_wpt_WPT_LF_TxDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_TxDataType* WPT_LF_TxDataType);
static int encode_iso20_wpt_WPT_LF_RxDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxDataType* WPT_LF_RxDataType);
static int encode_iso20_wpt_WPT_LF_TxDataListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_TxDataListType* WPT_LF_TxDataListType);
static int encode_iso20_wpt_KeyInfoType(exi_bitstream_t* stream, const struct iso20_wpt_KeyInfoType* KeyInfoType);
static int encode_iso20_wpt_WPT_TxRxSpecDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_TxRxSpecDataType* WPT_TxRxSpecDataType);
static int encode_iso20_wpt_WPT_LF_RxDataListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxDataListType* WPT_LF_RxDataListType);
static int encode_iso20_wpt_ObjectType(exi_bitstream_t* stream, const struct iso20_wpt_ObjectType* ObjectType);
static int encode_iso20_wpt_WPT_TxRxPackageSpecDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_TxRxPackageSpecDataType* WPT_TxRxPackageSpecDataType);
static int encode_iso20_wpt_WPT_LF_TransmitterDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_TransmitterDataType* WPT_LF_TransmitterDataType);
static int encode_iso20_wpt_AlternativeSECCType(exi_bitstream_t* stream, const struct iso20_wpt_AlternativeSECCType* AlternativeSECCType);
static int encode_iso20_wpt_WPT_LF_ReceiverDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_ReceiverDataType* WPT_LF_ReceiverDataType);
static int encode_iso20_wpt_WPT_LF_DataPackageType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_DataPackageType* WPT_LF_DataPackageType);
static int encode_iso20_wpt_DetailedCostType(exi_bitstream_t* stream, const struct iso20_wpt_DetailedCostType* DetailedCostType);
static int encode_iso20_wpt_SignatureType(exi_bitstream_t* stream, const struct iso20_wpt_SignatureType* SignatureType);
static int encode_iso20_wpt_DetailedTaxType(exi_bitstream_t* stream, const struct iso20_wpt_DetailedTaxType* DetailedTaxType);
static int encode_iso20_wpt_MessageHeaderType(exi_bitstream_t* stream, const struct iso20_wpt_MessageHeaderType* MessageHeaderType);
static int encode_iso20_wpt_SignaturePropertyType(exi_bitstream_t* stream, const struct iso20_wpt_SignaturePropertyType* SignaturePropertyType);
static int encode_iso20_wpt_DisplayParametersType(exi_bitstream_t* stream, const struct iso20_wpt_DisplayParametersType* DisplayParametersType);
static int encode_iso20_wpt_WPT_FinePositioningMethodListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningMethodListType* WPT_FinePositioningMethodListType);
static int encode_iso20_wpt_EVSEStatusType(exi_bitstream_t* stream, const struct iso20_wpt_EVSEStatusType* EVSEStatusType);
static int encode_iso20_wpt_WPT_PairingMethodListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_PairingMethodListType* WPT_PairingMethodListType);
static int encode_iso20_wpt_MeterInfoType(exi_bitstream_t* stream, const struct iso20_wpt_MeterInfoType* MeterInfoType);
static int encode_iso20_wpt_WPT_AlignmentCheckMethodListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_AlignmentCheckMethodListType* WPT_AlignmentCheckMethodListType);
static int encode_iso20_wpt_WPT_LF_DataPackageListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_DataPackageListType* WPT_LF_DataPackageListType);
static int encode_iso20_wpt_AlternativeSECCListType(exi_bitstream_t* stream, const struct iso20_wpt_AlternativeSECCListType* AlternativeSECCListType);
static int encode_iso20_wpt_ReceiptType(exi_bitstream_t* stream, const struct iso20_wpt_ReceiptType* ReceiptType);
static int encode_iso20_wpt_WPT_LF_SystemSetupDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_SystemSetupDataType* WPT_LF_SystemSetupDataType);
static int encode_iso20_wpt_WPT_EVPCPowerControlParameterType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_EVPCPowerControlParameterType* WPT_EVPCPowerControlParameterType);
static int encode_iso20_wpt_WPT_SPCPowerControlParameterType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_SPCPowerControlParameterType* WPT_SPCPowerControlParameterType);
static int encode_iso20_wpt_WPT_FinePositioningSetupReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningSetupReqType* WPT_FinePositioningSetupReqType);
static int encode_iso20_wpt_WPT_FinePositioningSetupResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningSetupResType* WPT_FinePositioningSetupResType);
static int encode_iso20_wpt_WPT_FinePositioningReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningReqType* WPT_FinePositioningReqType);
static int encode_iso20_wpt_WPT_FinePositioningResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningResType* WPT_FinePositioningResType);
static int encode_iso20_wpt_WPT_PairingReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_PairingReqType* WPT_PairingReqType);
static int encode_iso20_wpt_WPT_PairingResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_PairingResType* WPT_PairingResType);
static int encode_iso20_wpt_WPT_ChargeParameterDiscoveryReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeParameterDiscoveryReqType* WPT_ChargeParameterDiscoveryReqType);
static int encode_iso20_wpt_WPT_ChargeParameterDiscoveryResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeParameterDiscoveryResType* WPT_ChargeParameterDiscoveryResType);
static int encode_iso20_wpt_WPT_AlignmentCheckReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_AlignmentCheckReqType* WPT_AlignmentCheckReqType);
static int encode_iso20_wpt_WPT_AlignmentCheckResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_AlignmentCheckResType* WPT_AlignmentCheckResType);
static int encode_iso20_wpt_WPT_ChargeLoopReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeLoopReqType* WPT_ChargeLoopReqType);
static int encode_iso20_wpt_WPT_ChargeLoopResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeLoopResType* WPT_ChargeLoopResType);
static int encode_iso20_wpt_CLReqControlModeType(exi_bitstream_t* stream, const struct iso20_wpt_CLReqControlModeType* CLReqControlModeType);
static int encode_iso20_wpt_CLResControlModeType(exi_bitstream_t* stream, const struct iso20_wpt_CLResControlModeType* CLResControlModeType);
static int encode_iso20_wpt_ManifestType(exi_bitstream_t* stream, const struct iso20_wpt_ManifestType* ManifestType);
static int encode_iso20_wpt_SignaturePropertiesType(exi_bitstream_t* stream, const struct iso20_wpt_SignaturePropertiesType* SignaturePropertiesType);

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transform; type={http://www.w3.org/2000/09/xmldsig#}TransformType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1); XPath, string (0, 1);
static int encode_iso20_wpt_TransformType(exi_bitstream_t* stream, const struct iso20_wpt_TransformType* TransformType) {
    int grammar_id = 0;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 0:
            // Grammar: ID=0; read/write bits=1; START (Algorithm)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (anyURI); next=1

                // string should not be found in table, so add 2
                error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(TransformType->Algorithm.charactersLen + 2));
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_characters(stream, TransformType->Algorithm.charactersLen, TransformType->Algorithm.characters, iso20_wpt_Algorithm_CHARACTER_SIZE);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 1;
                    }
                }
            }
            break;
        case 1:
            // Grammar: ID=1; read/write bits=3; START (XPath), START (ANY), END Element, START (ANY)
            if (TransformType->XPath_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (XPath, string); next=2

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(TransformType->XPath.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, TransformType->XPath.charactersLen, TransformType->XPath.characters, iso20_wpt_XPath_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=1)
            //{
            // ***** //
            else if (TransformType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)TransformType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, TransformType->ANY.bytesLen, TransformType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transforms; type={http://www.w3.org/2000/09/xmldsig#}TransformsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Transform, TransformType (1, 1);
static int encode_iso20_wpt_TransformsType(exi_bitstream_t* stream, const struct iso20_wpt_TransformsType* TransformsType) {
    int grammar_id = 4;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 4:
            // Grammar: ID=4; read/write bits=1; START (Transform)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (TransformType); next=5
                error = encode_iso20_wpt_TransformType(stream, &TransformsType->Transform);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 5;
                }
            }
            break;
        case 5:
            // Grammar: ID=5; read/write bits=2; START (Transform), END Element
            if (1 == 0)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transform, TransformType); next=2
                    error = encode_iso20_wpt_TransformType(stream, &TransformsType->Transform);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}DSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: P, CryptoBinary (0, 1)(was 1, 1)(seq. ['P', 'Q']); Q, CryptoBinary (0, 1)(was 1, 1)(seq. ['P', 'Q']); G, CryptoBinary (0, 1); Y, CryptoBinary (1, 1); J, CryptoBinary (0, 1); Seed, CryptoBinary (0, 1)(was 1, 1)(seq. ['Seed', 'PgenCounter']); PgenCounter, CryptoBinary (0, 1)(was 1, 1)(seq. ['Seed', 'PgenCounter']);
static int encode_iso20_wpt_DSAKeyValueType(exi_bitstream_t* stream, const struct iso20_wpt_DSAKeyValueType* DSAKeyValueType) {
    int grammar_id = 6;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 6:
            // Grammar: ID=6; read/write bits=2; START (P), START (G), START (Y)
            if (DSAKeyValueType->P_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (P, base64Binary); next=7
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->P.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->P.bytesLen, DSAKeyValueType->P.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 7;
                                }
                            }
                        }
                    }
                }
            }
            else if (DSAKeyValueType->G_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (G, base64Binary); next=9
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->G.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->G.bytesLen, DSAKeyValueType->G.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 9;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Y, base64Binary); next=10
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->Y.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->Y.bytesLen, DSAKeyValueType->Y.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 10;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 7:
            // Grammar: ID=7; read/write bits=1; START (Q)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=8
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->Q.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->Q.bytesLen, DSAKeyValueType->Q.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 8;
                            }
                        }
                    }
                }
            }
            break;
        case 8:
            // Grammar: ID=8; read/write bits=2; START (G), START (Y)
            if (DSAKeyValueType->G_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (G, base64Binary); next=9
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->G.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->G.bytesLen, DSAKeyValueType->G.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 9;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Y, base64Binary); next=10
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->Y.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->Y.bytesLen, DSAKeyValueType->Y.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 10;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 9:
            // Grammar: ID=9; read/write bits=1; START (Y)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=10
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->Y.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->Y.bytesLen, DSAKeyValueType->Y.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 10;
                            }
                        }
                    }
                }
            }
            break;
        case 10:
            // Grammar: ID=10; read/write bits=2; START (J), START (Seed), END Element
            if (DSAKeyValueType->J_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (J, base64Binary); next=11
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->J.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->J.bytesLen, DSAKeyValueType->J.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 11;
                                }
                            }
                        }
                    }
                }
            }
            else if (DSAKeyValueType->Seed_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Seed, base64Binary); next=12
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->Seed.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->Seed.bytesLen, DSAKeyValueType->Seed.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 12;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 11:
            // Grammar: ID=11; read/write bits=2; START (Seed), END Element
            if (DSAKeyValueType->Seed_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Seed, base64Binary); next=12
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->Seed.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->Seed.bytesLen, DSAKeyValueType->Seed.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 12;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 12:
            // Grammar: ID=12; read/write bits=2; START (PgenCounter), END Element
            if (DSAKeyValueType->PgenCounter_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PgenCounter, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DSAKeyValueType->PgenCounter.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DSAKeyValueType->PgenCounter.bytesLen, DSAKeyValueType->PgenCounter.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial; type={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerialType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerName, string (1, 1); X509SerialNumber, integer (1, 1);
static int encode_iso20_wpt_X509IssuerSerialType(exi_bitstream_t* stream, const struct iso20_wpt_X509IssuerSerialType* X509IssuerSerialType) {
    int grammar_id = 13;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 13:
            // Grammar: ID=13; read/write bits=1; START (X509IssuerName)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=14

                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(X509IssuerSerialType->X509IssuerName.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, X509IssuerSerialType->X509IssuerName.charactersLen, X509IssuerSerialType->X509IssuerName.characters, iso20_wpt_X509IssuerName_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 14;
                            }
                        }
                    }
                }
            }
            break;
        case 14:
            // Grammar: ID=14; read/write bits=1; START (X509SerialNumber)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (decimal); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_integer_32(stream, X509IssuerSerialType->X509SerialNumber);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DigestMethod; type={http://www.w3.org/2000/09/xmldsig#}DigestMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_DigestMethodType(exi_bitstream_t* stream, const struct iso20_wpt_DigestMethodType* DigestMethodType) {
    int grammar_id = 15;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 15:
            // Grammar: ID=15; read/write bits=1; START (Algorithm)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (anyURI); next=16

                // string should not be found in table, so add 2
                error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(DigestMethodType->Algorithm.charactersLen + 2));
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_characters(stream, DigestMethodType->Algorithm.charactersLen, DigestMethodType->Algorithm.characters, iso20_wpt_Algorithm_CHARACTER_SIZE);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 16;
                    }
                }
            }
            break;
        case 16:
            // Grammar: ID=16; read/write bits=2; START (ANY), END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (DigestMethodType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)DigestMethodType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, DigestMethodType->ANY.bytesLen, DigestMethodType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}RSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Modulus, CryptoBinary (1, 1); Exponent, CryptoBinary (1, 1);
static int encode_iso20_wpt_RSAKeyValueType(exi_bitstream_t* stream, const struct iso20_wpt_RSAKeyValueType* RSAKeyValueType) {
    int grammar_id = 17;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 17:
            // Grammar: ID=17; read/write bits=1; START (Modulus)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=18
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)RSAKeyValueType->Modulus.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, RSAKeyValueType->Modulus.bytesLen, RSAKeyValueType->Modulus.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 18;
                            }
                        }
                    }
                }
            }
            break;
        case 18:
            // Grammar: ID=18; read/write bits=1; START (Exponent)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)RSAKeyValueType->Exponent.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, RSAKeyValueType->Exponent.bytesLen, RSAKeyValueType->Exponent.bytes, iso20_wpt_CryptoBinary_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod; type={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_CanonicalizationMethodType(exi_bitstream_t* stream, const struct iso20_wpt_CanonicalizationMethodType* CanonicalizationMethodType) {
    int grammar_id = 19;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 19:
            // Grammar: ID=19; read/write bits=1; START (Algorithm)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (anyURI); next=20

                // string should not be found in table, so add 2
                error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(CanonicalizationMethodType->Algorithm.charactersLen + 2));
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_characters(stream, CanonicalizationMethodType->Algorithm.charactersLen, CanonicalizationMethodType->Algorithm.characters, iso20_wpt_Algorithm_CHARACTER_SIZE);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 20;
                    }
                }
            }
            break;
        case 20:
            // Grammar: ID=20; read/write bits=2; START (ANY), END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (CanonicalizationMethodType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)CanonicalizationMethodType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, CanonicalizationMethodType->ANY.bytesLen, CanonicalizationMethodType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}PulseSequenceOrder; type={urn:iso:std:iso:15118:-20:WPT}WPT_TxRxPulseOrderType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: IndexNumber, unsignedShort (1, 1); TxRxIdentifier, numericIDType (1, 1);
static int encode_iso20_wpt_WPT_TxRxPulseOrderType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_TxRxPulseOrderType* WPT_TxRxPulseOrderType) {
    int grammar_id = 21;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 21:
            // Grammar: ID=21; read/write bits=1; START (IndexNumber)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=22
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_TxRxPulseOrderType->IndexNumber);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 22;
                        }
                    }
                }
            }
            break;
        case 22:
            // Grammar: ID=22; read/write bits=1; START (TxRxIdentifier)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_32(stream, WPT_TxRxPulseOrderType->TxRxIdentifier);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureMethod; type={http://www.w3.org/2000/09/xmldsig#}SignatureMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); HMACOutputLength, HMACOutputLengthType (0, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_SignatureMethodType(exi_bitstream_t* stream, const struct iso20_wpt_SignatureMethodType* SignatureMethodType) {
    int grammar_id = 23;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 23:
            // Grammar: ID=23; read/write bits=1; START (Algorithm)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (anyURI); next=24

                // string should not be found in table, so add 2
                error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignatureMethodType->Algorithm.charactersLen + 2));
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_characters(stream, SignatureMethodType->Algorithm.charactersLen, SignatureMethodType->Algorithm.characters, iso20_wpt_Algorithm_CHARACTER_SIZE);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 24;
                    }
                }
            }
            break;
        case 24:
            // Grammar: ID=24; read/write bits=3; START (HMACOutputLength), START (ANY), END Element, START (ANY)
            if (SignatureMethodType->HMACOutputLength_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (HMACOutputLength, integer); next=25
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_integer_32(stream, SignatureMethodType->HMACOutputLength);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 25;
                            }
                        }
                    }
                }
            }
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=1)
            //{
            // ***** //
            else if (SignatureMethodType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SignatureMethodType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, SignatureMethodType->ANY.bytesLen, SignatureMethodType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 25:
            // Grammar: ID=25; read/write bits=2; START (ANY), END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (SignatureMethodType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SignatureMethodType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, SignatureMethodType->ANY.bytesLen, SignatureMethodType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyValue; type={http://www.w3.org/2000/09/xmldsig#}KeyValueType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: DSAKeyValue, DSAKeyValueType (0, 1); RSAKeyValue, RSAKeyValueType (0, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_KeyValueType(exi_bitstream_t* stream, const struct iso20_wpt_KeyValueType* KeyValueType) {
    int grammar_id = 26;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 26:
            // Grammar: ID=26; read/write bits=2; START (DSAKeyValue), START (RSAKeyValue), START (ANY)
            if (KeyValueType->DSAKeyValue_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (DSAKeyValue, DSAKeyValueType); next=2
                    error = encode_iso20_wpt_DSAKeyValueType(stream, &KeyValueType->DSAKeyValue);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyValueType->RSAKeyValue_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RSAKeyValue, RSAKeyValueType); next=2
                    error = encode_iso20_wpt_RSAKeyValueType(stream, &KeyValueType->RSAKeyValue);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyValueType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)KeyValueType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, KeyValueType->ANY.bytesLen, KeyValueType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}TxRxPosition; type={urn:iso:std:iso:15118:-20:WPT}WPT_CoordinateXYZType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Coord_X, short (1, 1); Coord_Y, short (1, 1); Coord_Z, short (1, 1);
static int encode_iso20_wpt_WPT_CoordinateXYZType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_CoordinateXYZType* WPT_CoordinateXYZType) {
    int grammar_id = 27;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 27:
            // Grammar: ID=27; read/write bits=1; START (Coord_X)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (int); next=28
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_integer_16(stream, WPT_CoordinateXYZType->Coord_X);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 28;
                        }
                    }
                }
            }
            break;
        case 28:
            // Grammar: ID=28; read/write bits=1; START (Coord_Y)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (int); next=29
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_integer_16(stream, WPT_CoordinateXYZType->Coord_Y);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 29;
                        }
                    }
                }
            }
            break;
        case 29:
            // Grammar: ID=29; read/write bits=1; START (Coord_Z)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (int); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_integer_16(stream, WPT_CoordinateXYZType->Coord_Z);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Reference; type={http://www.w3.org/2000/09/xmldsig#}ReferenceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1); DigestMethod, DigestMethodType (1, 1); DigestValue, DigestValueType (1, 1);
static int encode_iso20_wpt_ReferenceType(exi_bitstream_t* stream, const struct iso20_wpt_ReferenceType* ReferenceType) {
    int grammar_id = 30;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 30:
            // Grammar: ID=30; read/write bits=3; START (Id), START (Type), START (URI), START (Transforms), START (DigestMethod)
            if (ReferenceType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=31

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ReferenceType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ReferenceType->Id.charactersLen, ReferenceType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 31;
                        }
                    }
                }
            }
            else if (ReferenceType->Type_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Type, anyURI); next=32

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ReferenceType->Type.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso20_wpt_Type_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 32;
                        }
                    }
                }
            }
            else if (ReferenceType->URI_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (URI, anyURI); next=33

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ReferenceType->URI.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_wpt_URI_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 33;
                        }
                    }
                }
            }
            else if (ReferenceType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=34
                    error = encode_iso20_wpt_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 34;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (DigestMethod, DigestMethodType); next=35
                    error = encode_iso20_wpt_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 35;
                    }
                }
            }
            break;
        case 31:
            // Grammar: ID=31; read/write bits=3; START (Type), START (URI), START (Transforms), START (DigestMethod)
            if (ReferenceType->Type_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Type, anyURI); next=32

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ReferenceType->Type.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso20_wpt_Type_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 32;
                        }
                    }
                }
            }
            else if (ReferenceType->URI_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (URI, anyURI); next=33

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ReferenceType->URI.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_wpt_URI_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 33;
                        }
                    }
                }
            }
            else if (ReferenceType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=34
                    error = encode_iso20_wpt_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 34;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (DigestMethod, DigestMethodType); next=35
                    error = encode_iso20_wpt_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 35;
                    }
                }
            }
            break;
        case 32:
            // Grammar: ID=32; read/write bits=2; START (URI), START (Transforms), START (DigestMethod)
            if (ReferenceType->URI_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (URI, anyURI); next=33

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ReferenceType->URI.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_wpt_URI_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 33;
                        }
                    }
                }
            }
            else if (ReferenceType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=34
                    error = encode_iso20_wpt_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 34;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (DigestMethod, DigestMethodType); next=35
                    error = encode_iso20_wpt_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 35;
                    }
                }
            }
            break;
        case 33:
            // Grammar: ID=33; read/write bits=2; START (Transforms), START (DigestMethod)
            if (ReferenceType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=34
                    error = encode_iso20_wpt_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 34;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (DigestMethod, DigestMethodType); next=35
                    error = encode_iso20_wpt_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 35;
                    }
                }
            }
            break;
        case 34:
            // Grammar: ID=34; read/write bits=1; START (DigestMethod)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (DigestMethodType); next=35
                error = encode_iso20_wpt_DigestMethodType(stream, &ReferenceType->DigestMethod);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 35;
                }
            }
            break;
        case 35:
            // Grammar: ID=35; read/write bits=1; START (DigestValue)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)ReferenceType->DigestValue.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, ReferenceType->DigestValue.bytesLen, ReferenceType->DigestValue.bytes, iso20_wpt_DigestValueType_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RetrievalMethod; type={http://www.w3.org/2000/09/xmldsig#}RetrievalMethodType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1);
static int encode_iso20_wpt_RetrievalMethodType(exi_bitstream_t* stream, const struct iso20_wpt_RetrievalMethodType* RetrievalMethodType) {
    int grammar_id = 36;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 36:
            // Grammar: ID=36; read/write bits=3; START (Type), START (URI), START (Transforms), END Element
            if (RetrievalMethodType->Type_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Type, anyURI); next=37

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(RetrievalMethodType->Type.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, RetrievalMethodType->Type.charactersLen, RetrievalMethodType->Type.characters, iso20_wpt_Type_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 37;
                        }
                    }
                }
            }
            else if (RetrievalMethodType->URI_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (URI, anyURI); next=38

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(RetrievalMethodType->URI.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso20_wpt_URI_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 38;
                        }
                    }
                }
            }
            else if (RetrievalMethodType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=2
                    error = encode_iso20_wpt_TransformsType(stream, &RetrievalMethodType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 37:
            // Grammar: ID=37; read/write bits=2; START (URI), START (Transforms), END Element
            if (RetrievalMethodType->URI_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (URI, anyURI); next=38

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(RetrievalMethodType->URI.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso20_wpt_URI_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 38;
                        }
                    }
                }
            }
            else if (RetrievalMethodType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=2
                    error = encode_iso20_wpt_TransformsType(stream, &RetrievalMethodType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 38:
            // Grammar: ID=38; read/write bits=2; START (Transforms), END Element
            if (RetrievalMethodType->Transforms_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Transforms, TransformsType); next=2
                    error = encode_iso20_wpt_TransformsType(stream, &RetrievalMethodType->Transforms);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509Data; type={http://www.w3.org/2000/09/xmldsig#}X509DataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerSerial, X509IssuerSerialType (0, 1); X509SKI, base64Binary (0, 1); X509SubjectName, string (0, 1); X509Certificate, base64Binary (0, 1); X509CRL, base64Binary (0, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_X509DataType(exi_bitstream_t* stream, const struct iso20_wpt_X509DataType* X509DataType) {
    int grammar_id = 39;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 39:
            // Grammar: ID=39; read/write bits=3; START (X509IssuerSerial), START (X509SKI), START (X509SubjectName), START (X509Certificate), START (X509CRL), START (ANY)
            if (X509DataType->X509IssuerSerial_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509IssuerSerial, X509IssuerSerialType); next=2
                    error = encode_iso20_wpt_X509IssuerSerialType(stream, &X509DataType->X509IssuerSerial);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (X509DataType->X509SKI_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509SKI, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)X509DataType->X509SKI.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, X509DataType->X509SKI.bytesLen, X509DataType->X509SKI.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (X509DataType->X509SubjectName_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509SubjectName, string); next=2

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(X509DataType->X509SubjectName.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, X509DataType->X509SubjectName.charactersLen, X509DataType->X509SubjectName.characters, iso20_wpt_X509SubjectName_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (X509DataType->X509Certificate_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509Certificate, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)X509DataType->X509Certificate.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, X509DataType->X509Certificate.bytesLen, X509DataType->X509Certificate.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (X509DataType->X509CRL_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509CRL, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)X509DataType->X509CRL.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, X509DataType->X509CRL.bytesLen, X509DataType->X509CRL.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (X509DataType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)X509DataType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, X509DataType->ANY.bytesLen, X509DataType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}PGPData; type={http://www.w3.org/2000/09/xmldsig#}PGPDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True; sequence=True (2;
// Particle: PGPKeyID, base64Binary (1, 1); PGPKeyPacket, base64Binary (0, 1); ANY, anyType (0, 1); PGPKeyPacket, base64Binary (1, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_PGPDataType(exi_bitstream_t* stream, const struct iso20_wpt_PGPDataType* PGPDataType) {
    int grammar_id = 40;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 40:
            // Grammar: ID=40; read/write bits=2; START (PGPKeyID), START (PGPKeyPacket)
            if (PGPDataType->choice_1_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PGPKeyID, base64Binary); next=41
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_1.PGPKeyID.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_1.PGPKeyID.bytesLen, PGPDataType->choice_1.PGPKeyID.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 41;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PGPKeyPacket, base64Binary); next=42
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_1.PGPKeyPacket.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_1.PGPKeyPacket.bytesLen, PGPDataType->choice_1.PGPKeyPacket.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 42;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 41:
            // Grammar: ID=41; read/write bits=3; START (PGPKeyPacket), START (ANY), END Element, START (ANY)
            if (PGPDataType->choice_1_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PGPKeyPacket, base64Binary); next=42
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_1.PGPKeyPacket.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_1.PGPKeyPacket.bytesLen, PGPDataType->choice_1.PGPKeyPacket.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 42;
                                }
                            }
                        }
                    }
                }
            }
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=1)
            //{
            // ***** //
            else if (PGPDataType->choice_1_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=43
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_1.ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_1.ANY.bytesLen, PGPDataType->choice_1.ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 43;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 42:
            // Grammar: ID=42; read/write bits=3; START (ANY), END Element, END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (PGPDataType->choice_1_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=43
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_1.ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_1.ANY.bytesLen, PGPDataType->choice_1.ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 43;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 43:
            // Grammar: ID=43; read/write bits=1; START (PGPKeyPacket)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=44
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_2.PGPKeyPacket.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_2.PGPKeyPacket.bytesLen, PGPDataType->choice_2.PGPKeyPacket.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 44;
                            }
                        }
                    }
                }
            }
            break;
        case 44:
            // Grammar: ID=44; read/write bits=2; START (ANY), END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (PGPDataType->choice_2_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=43
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)PGPDataType->choice_2.ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, PGPDataType->choice_2.ANY.bytesLen, PGPDataType->choice_2.ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 43;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SPKIData; type={http://www.w3.org/2000/09/xmldsig#}SPKIDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SPKISexp, base64Binary (1, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_SPKIDataType(exi_bitstream_t* stream, const struct iso20_wpt_SPKIDataType* SPKIDataType) {
    int grammar_id = 45;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 45:
            // Grammar: ID=45; read/write bits=1; START (SPKISexp)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=46
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SPKIDataType->SPKISexp.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, SPKIDataType->SPKISexp.bytesLen, SPKIDataType->SPKISexp.bytes, iso20_wpt_base64Binary_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 46;
                            }
                        }
                    }
                }
            }
            break;
        case 46:
            // Grammar: ID=46; read/write bits=2; START (ANY), END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (SPKIDataType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SPKIDataType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, SPKIDataType->ANY.bytesLen, SPKIDataType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignedInfo; type={http://www.w3.org/2000/09/xmldsig#}SignedInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); CanonicalizationMethod, CanonicalizationMethodType (1, 1); SignatureMethod, SignatureMethodType (1, 1); Reference, ReferenceType (1, 4);
static int encode_iso20_wpt_SignedInfoType(exi_bitstream_t* stream, const struct iso20_wpt_SignedInfoType* SignedInfoType) {
    int grammar_id = 47;
    int done = 0;
    int error = 0;
    uint16_t Reference_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 47:
            // Grammar: ID=47; read/write bits=2; START (Id), START (CanonicalizationMethod)
            if (SignedInfoType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=48

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignedInfoType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, SignedInfoType->Id.charactersLen, SignedInfoType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 48;
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType); next=49
                    error = encode_iso20_wpt_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 49;
                    }
                }
            }
            break;
        case 48:
            // Grammar: ID=48; read/write bits=1; START (CanonicalizationMethod)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (CanonicalizationMethodType); next=49
                error = encode_iso20_wpt_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 49;
                }
            }
            break;
        case 49:
            // Grammar: ID=49; read/write bits=1; START (SignatureMethod)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (SignatureMethodType); next=50
                error = encode_iso20_wpt_SignatureMethodType(stream, &SignedInfoType->SignatureMethod);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 50;
                }
            }
            break;
        case 50:
            // Grammar: ID=50; read/write bits=1; START (Reference)
            if (Reference_currentIndex < SignedInfoType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=51
                    error = encode_iso20_wpt_ReferenceType(stream, &SignedInfoType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 51;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 51:
            // Grammar: ID=51; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < SignedInfoType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=52
                    error = encode_iso20_wpt_ReferenceType(stream, &SignedInfoType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 52;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 52:
            // Grammar: ID=52; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < SignedInfoType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=53
                    error = encode_iso20_wpt_ReferenceType(stream, &SignedInfoType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 53;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 53:
            // Grammar: ID=53; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < SignedInfoType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=54
                    error = encode_iso20_wpt_ReferenceType(stream, &SignedInfoType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 54;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 54:
            // Grammar: ID=54; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < SignedInfoType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=2
                    error = encode_iso20_wpt_ReferenceType(stream, &SignedInfoType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureValue; type={http://www.w3.org/2000/09/xmldsig#}SignatureValueType; base type=base64Binary; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); CONTENT, SignatureValueType (1, 1);
static int encode_iso20_wpt_SignatureValueType(exi_bitstream_t* stream, const struct iso20_wpt_SignatureValueType* SignatureValueType) {
    int grammar_id = 55;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 55:
            // Grammar: ID=55; read/write bits=2; START (Id), START (CONTENT)
            if (SignatureValueType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=56

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignatureValueType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, SignatureValueType->Id.charactersLen, SignatureValueType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 56;
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (CONTENT, base64Binary); next=2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SignatureValueType->CONTENT.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, SignatureValueType->CONTENT.bytes, iso20_wpt_SignatureValueType_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 56:
            // Grammar: ID=56; read/write bits=1; START (CONTENT)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=2
                error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SignatureValueType->CONTENT.bytesLen);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, SignatureValueType->CONTENT.bytes, iso20_wpt_SignatureValueType_BYTES_SIZE);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}SignalFrequency; type={urn:iso:std:iso:15118:-20:CommonTypes}RationalNumberType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Exponent, byte (1, 1); Value, short (1, 1);
static int encode_iso20_wpt_RationalNumberType(exi_bitstream_t* stream, const struct iso20_wpt_RationalNumberType* RationalNumberType) {
    int grammar_id = 57;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 57:
            // Grammar: ID=57; read/write bits=1; START (Exponent)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (short); next=58
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // type has min_value = -128
                    error = exi_basetypes_encoder_nbit_uint(stream, 8, RationalNumberType->Exponent + -128);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 58;
                        }
                    }
                }
            }
            break;
        case 58:
            // Grammar: ID=58; read/write bits=1; START (Value)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (int); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_integer_16(stream, RationalNumberType->Value);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}RSSIDataList; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_RxRSSIType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TxIdentifier, numericIDType (1, 1); RSSI, RationalNumberType (1, 1);
static int encode_iso20_wpt_WPT_LF_RxRSSIType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxRSSIType* WPT_LF_RxRSSIType) {
    int grammar_id = 59;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 59:
            // Grammar: ID=59; read/write bits=1; START (TxIdentifier)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=60
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_32(stream, WPT_LF_RxRSSIType->TxIdentifier);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 60;
                        }
                    }
                }
            }
            break;
        case 60:
            // Grammar: ID=60; read/write bits=1; START (RSSI)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=2
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_LF_RxRSSIType->RSSI);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}RSSIData; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_RxRSSIListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: RSSIDataList, WPT_LF_RxRSSIType (1, 1);
static int encode_iso20_wpt_WPT_LF_RxRSSIListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxRSSIListType* WPT_LF_RxRSSIListType) {
    int grammar_id = 61;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 61:
            // Grammar: ID=61; read/write bits=1; START (RSSIDataList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_LF_RxRSSIType); next=2
                error = encode_iso20_wpt_WPT_LF_RxRSSIType(stream, &WPT_LF_RxRSSIListType->RSSIDataList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_LF_TxDataList; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_TxDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TxIdentifier, numericIDType (1, 1); EIRP, RationalNumberType (1, 1);
static int encode_iso20_wpt_WPT_LF_TxDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_TxDataType* WPT_LF_TxDataType) {
    int grammar_id = 62;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 62:
            // Grammar: ID=62; read/write bits=1; START (TxIdentifier)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=63
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_32(stream, WPT_LF_TxDataType->TxIdentifier);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 63;
                        }
                    }
                }
            }
            break;
        case 63:
            // Grammar: ID=63; read/write bits=1; START (EIRP)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=2
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_LF_TxDataType->EIRP);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_LF_RxDataList; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_RxDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: RxIdentifier, numericIDType (1, 1); RSSIData, WPT_LF_RxRSSIListType (1, 1);
static int encode_iso20_wpt_WPT_LF_RxDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxDataType* WPT_LF_RxDataType) {
    int grammar_id = 64;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 64:
            // Grammar: ID=64; read/write bits=1; START (RxIdentifier)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=65
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_32(stream, WPT_LF_RxDataType->RxIdentifier);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 65;
                        }
                    }
                }
            }
            break;
        case 65:
            // Grammar: ID=65; read/write bits=1; START (RSSIData)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_LF_RxRSSIListType); next=2
                error = encode_iso20_wpt_WPT_LF_RxRSSIListType(stream, &WPT_LF_RxDataType->RSSIData);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}LF_TxData; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_TxDataListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: WPT_LF_TxDataList, WPT_LF_TxDataType (1, 1);
static int encode_iso20_wpt_WPT_LF_TxDataListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_TxDataListType* WPT_LF_TxDataListType) {
    int grammar_id = 66;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 66:
            // Grammar: ID=66; read/write bits=1; START (WPT_LF_TxDataList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_LF_TxDataType); next=2
                error = encode_iso20_wpt_WPT_LF_TxDataType(stream, &WPT_LF_TxDataListType->WPT_LF_TxDataList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyInfo; type={http://www.w3.org/2000/09/xmldsig#}KeyInfoType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); KeyName, string (0, 1); KeyValue, KeyValueType (0, 1); RetrievalMethod, RetrievalMethodType (0, 1); X509Data, X509DataType (0, 1); PGPData, PGPDataType (0, 1); SPKIData, SPKIDataType (0, 1); MgmtData, string (0, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_KeyInfoType(exi_bitstream_t* stream, const struct iso20_wpt_KeyInfoType* KeyInfoType) {
    int grammar_id = 67;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 67:
            // Grammar: ID=67; read/write bits=4; START (Id), START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            if (KeyInfoType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=68

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(KeyInfoType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, KeyInfoType->Id.charactersLen, KeyInfoType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 68;
                        }
                    }
                }
            }
            else if (KeyInfoType->KeyName_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (KeyName, string); next=2

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(KeyInfoType->KeyName.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso20_wpt_KeyName_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (KeyInfoType->KeyValue_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (KeyValue, KeyValueType); next=2
                    error = encode_iso20_wpt_KeyValueType(stream, &KeyInfoType->KeyValue);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->RetrievalMethod_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RetrievalMethod, RetrievalMethodType); next=2
                    error = encode_iso20_wpt_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->X509Data_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509Data, X509DataType); next=2
                    error = encode_iso20_wpt_X509DataType(stream, &KeyInfoType->X509Data);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->PGPData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PGPData, PGPDataType); next=2
                    error = encode_iso20_wpt_PGPDataType(stream, &KeyInfoType->PGPData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->SPKIData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SPKIData, SPKIDataType); next=2
                    error = encode_iso20_wpt_SPKIDataType(stream, &KeyInfoType->SPKIData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->MgmtData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 7);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MgmtData, string); next=2

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(KeyInfoType->MgmtData.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso20_wpt_MgmtData_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (KeyInfoType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 8);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)KeyInfoType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, KeyInfoType->ANY.bytesLen, KeyInfoType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 68:
            // Grammar: ID=68; read/write bits=4; START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            if (KeyInfoType->KeyName_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (KeyName, string); next=2

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(KeyInfoType->KeyName.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso20_wpt_KeyName_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (KeyInfoType->KeyValue_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (KeyValue, KeyValueType); next=2
                    error = encode_iso20_wpt_KeyValueType(stream, &KeyInfoType->KeyValue);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->RetrievalMethod_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RetrievalMethod, RetrievalMethodType); next=2
                    error = encode_iso20_wpt_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->X509Data_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (X509Data, X509DataType); next=2
                    error = encode_iso20_wpt_X509DataType(stream, &KeyInfoType->X509Data);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->PGPData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PGPData, PGPDataType); next=2
                    error = encode_iso20_wpt_PGPDataType(stream, &KeyInfoType->PGPData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->SPKIData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SPKIData, SPKIDataType); next=2
                    error = encode_iso20_wpt_SPKIDataType(stream, &KeyInfoType->SPKIData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else if (KeyInfoType->MgmtData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MgmtData, string); next=2

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(KeyInfoType->MgmtData.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso20_wpt_MgmtData_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else if (KeyInfoType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 7);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)KeyInfoType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, KeyInfoType->ANY.bytesLen, KeyInfoType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}TxSpecData; type={urn:iso:std:iso:15118:-20:WPT}WPT_TxRxSpecDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TxRxIdentifier, numericIDType (1, 1); TxRxPosition, WPT_CoordinateXYZType (1, 1); TxRxOrientation, WPT_CoordinateXYZType (1, 1);
static int encode_iso20_wpt_WPT_TxRxSpecDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_TxRxSpecDataType* WPT_TxRxSpecDataType) {
    int grammar_id = 69;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 69:
            // Grammar: ID=69; read/write bits=1; START (TxRxIdentifier)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=70
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_32(stream, WPT_TxRxSpecDataType->TxRxIdentifier);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 70;
                        }
                    }
                }
            }
            break;
        case 70:
            // Grammar: ID=70; read/write bits=1; START (TxRxPosition)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_CoordinateXYZType); next=71
                error = encode_iso20_wpt_WPT_CoordinateXYZType(stream, &WPT_TxRxSpecDataType->TxRxPosition);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 71;
                }
            }
            break;
        case 71:
            // Grammar: ID=71; read/write bits=1; START (TxRxOrientation)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_CoordinateXYZType); next=2
                error = encode_iso20_wpt_WPT_CoordinateXYZType(stream, &WPT_TxRxSpecDataType->TxRxOrientation);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}LF_RxData; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_RxDataListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: WPT_LF_RxDataList, WPT_LF_RxDataType (1, 1);
static int encode_iso20_wpt_WPT_LF_RxDataListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_RxDataListType* WPT_LF_RxDataListType) {
    int grammar_id = 72;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 72:
            // Grammar: ID=72; read/write bits=1; START (WPT_LF_RxDataList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_LF_RxDataType); next=2
                error = encode_iso20_wpt_WPT_LF_RxDataType(stream, &WPT_LF_RxDataListType->WPT_LF_RxDataList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Object; type={http://www.w3.org/2000/09/xmldsig#}ObjectType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Encoding, anyURI (0, 1); Id, ID (0, 1); MimeType, string (0, 1); ANY, anyType (0, 1)(old 1, 1);
static int encode_iso20_wpt_ObjectType(exi_bitstream_t* stream, const struct iso20_wpt_ObjectType* ObjectType) {
    int grammar_id = 73;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 73:
            // Grammar: ID=73; read/write bits=3; START (Encoding), START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            if (ObjectType->Encoding_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Encoding, anyURI); next=74

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ObjectType->Encoding.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ObjectType->Encoding.charactersLen, ObjectType->Encoding.characters, iso20_wpt_Encoding_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 74;
                        }
                    }
                }
            }
            else if (ObjectType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=75

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ObjectType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 75;
                        }
                    }
                }
            }
            else if (ObjectType->MimeType_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MimeType, string); next=76

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ObjectType->MimeType.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_wpt_MimeType_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 76;
                        }
                    }
                }
            }
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=3)
            //{
            // ***** //
            else if (ObjectType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)ObjectType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, ObjectType->ANY.bytesLen, ObjectType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 74:
            // Grammar: ID=74; read/write bits=3; START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            if (ObjectType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=75

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ObjectType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 75;
                        }
                    }
                }
            }
            else if (ObjectType->MimeType_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MimeType, string); next=76

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ObjectType->MimeType.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_wpt_MimeType_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 76;
                        }
                    }
                }
            }
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=2)
            //{
            // ***** //
            else if (ObjectType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)ObjectType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, ObjectType->ANY.bytesLen, ObjectType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 75:
            // Grammar: ID=75; read/write bits=3; START (MimeType), START (ANY), END Element, START (ANY)
            if (ObjectType->MimeType_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MimeType, string); next=76

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ObjectType->MimeType.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_wpt_MimeType_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 76;
                        }
                    }
                }
            }
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=1)
            //{
            // ***** //
            else if (ObjectType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)ObjectType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, ObjectType->ANY.bytesLen, ObjectType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 76:
            // Grammar: ID=76; read/write bits=2; START (ANY), END Element, START (ANY)
            // ***** //
            //{
                // No code for unsupported generic event: ANY (index=0)
            //{
            // ***** //
            if (ObjectType->ANY_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ANY, base64Binary); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)ObjectType->ANY.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, ObjectType->ANY.bytesLen, ObjectType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}TxPackageSpecData; type={urn:iso:std:iso:15118:-20:WPT}WPT_TxRxPackageSpecDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PulseSequenceOrder, WPT_TxRxPulseOrderType (2, 255); PulseSeparationTime, unsignedShort (1, 1); PulseDuration, unsignedShort (1, 1); PackageSeparationTime, unsignedShort (1, 1);
static int encode_iso20_wpt_WPT_TxRxPackageSpecDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_TxRxPackageSpecDataType* WPT_TxRxPackageSpecDataType) {
    int grammar_id = 77;
    int done = 0;
    int error = 0;
    uint16_t PulseSequenceOrder_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 77:
            // Grammar: ID=77; read/write bits=1; START (PulseSequenceOrder)
            if (PulseSequenceOrder_currentIndex < WPT_TxRxPackageSpecDataType->PulseSequenceOrder.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_TxRxPulseOrderType); next=78
                    error = encode_iso20_wpt_WPT_TxRxPulseOrderType(stream, &WPT_TxRxPackageSpecDataType->PulseSequenceOrder.array[PulseSequenceOrder_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 78;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 78:
            // Grammar: ID=78; read/write bits=1; LOOP (PulseSequenceOrder)
            if (PulseSequenceOrder_currentIndex < WPT_TxRxPackageSpecDataType->PulseSequenceOrder.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: LOOP (WPT_TxRxPulseOrderType); next=3
                    error = encode_iso20_wpt_WPT_TxRxPulseOrderType(stream, &WPT_TxRxPackageSpecDataType->PulseSequenceOrder.array[PulseSequenceOrder_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 3;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 79:
            // Grammar: ID=79; read/write bits=1; START (PulseSeparationTime)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=80
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_TxRxPackageSpecDataType->PulseSeparationTime);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 80;
                        }
                    }
                }
            }
            break;
        case 80:
            // Grammar: ID=80; read/write bits=1; START (PulseDuration)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=81
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_TxRxPackageSpecDataType->PulseDuration);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 81;
                        }
                    }
                }
            }
            break;
        case 81:
            // Grammar: ID=81; read/write bits=1; START (PackageSeparationTime)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_TxRxPackageSpecDataType->PackageSeparationTime);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}LF_TransmitterSetupData; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_TransmitterDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: NumberOfTransmitters, unsignedByte (1, 1); SignalFrequency, RationalNumberType (1, 1); TxSpecData, WPT_TxRxSpecDataType (2, 255); TxPackageSpecData, WPT_TxRxPackageSpecDataType (0, 1);
static int encode_iso20_wpt_WPT_LF_TransmitterDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_TransmitterDataType* WPT_LF_TransmitterDataType) {
    int grammar_id = 82;
    int done = 0;
    int error = 0;
    uint16_t TxSpecData_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 82:
            // Grammar: ID=82; read/write bits=1; START (NumberOfTransmitters)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedShort); next=83
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 8, WPT_LF_TransmitterDataType->NumberOfTransmitters);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 83;
                        }
                    }
                }
            }
            break;
        case 83:
            // Grammar: ID=83; read/write bits=1; START (SignalFrequency)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=84
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_LF_TransmitterDataType->SignalFrequency);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 84;
                }
            }
            break;
        case 84:
            // Grammar: ID=84; read/write bits=2; START (TxSpecData), END Element
            if (TxSpecData_currentIndex < WPT_LF_TransmitterDataType->TxSpecData.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_TxRxSpecDataType); next=85
                    error = encode_iso20_wpt_WPT_TxRxSpecDataType(stream, &WPT_LF_TransmitterDataType->TxSpecData.array[TxSpecData_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 85;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 85:
            // Grammar: ID=85; read/write bits=1; LOOP (TxSpecData)
            if (TxSpecData_currentIndex < WPT_LF_TransmitterDataType->TxSpecData.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: LOOP (WPT_TxRxSpecDataType); next=3
                    error = encode_iso20_wpt_WPT_TxRxSpecDataType(stream, &WPT_LF_TransmitterDataType->TxSpecData.array[TxSpecData_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 3;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 86:
            // Grammar: ID=86; read/write bits=2; START (TxPackageSpecData), END Element
            if (WPT_LF_TransmitterDataType->TxPackageSpecData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TxPackageSpecData, WPT_TxRxPackageSpecDataType); next=2
                    error = encode_iso20_wpt_WPT_TxRxPackageSpecDataType(stream, &WPT_LF_TransmitterDataType->TxPackageSpecData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}AlternativeSECC; type={urn:iso:std:iso:15118:-20:WPT}AlternativeSECCType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SSID, identifierType (0, 1); BSSID, bssidType (0, 1); IPAddress, ipaddressType (0, 1); Port, unsignedShort (0, 1);
static int encode_iso20_wpt_AlternativeSECCType(exi_bitstream_t* stream, const struct iso20_wpt_AlternativeSECCType* AlternativeSECCType) {
    int grammar_id = 87;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 87:
            // Grammar: ID=87; read/write bits=3; START (SSID), START (BSSID), START (IPAddress), START (Port), END Element
            if (AlternativeSECCType->SSID_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SSID, string); next=88

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(AlternativeSECCType->SSID.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, AlternativeSECCType->SSID.charactersLen, AlternativeSECCType->SSID.characters, iso20_wpt_SSID_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 88;
                                }
                            }
                        }
                    }
                }
            }
            else if (AlternativeSECCType->BSSID_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BSSID, string); next=89

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(AlternativeSECCType->BSSID.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, AlternativeSECCType->BSSID.charactersLen, AlternativeSECCType->BSSID.characters, iso20_wpt_BSSID_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 89;
                                }
                            }
                        }
                    }
                }
            }
            else if (AlternativeSECCType->IPAddress_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (IPAddress, string); next=90

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(AlternativeSECCType->IPAddress.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, AlternativeSECCType->IPAddress.charactersLen, AlternativeSECCType->IPAddress.characters, iso20_wpt_IPAddress_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 90;
                                }
                            }
                        }
                    }
                }
            }
            else if (AlternativeSECCType->Port_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Port, unsignedInt); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, AlternativeSECCType->Port);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 88:
            // Grammar: ID=88; read/write bits=3; START (BSSID), START (IPAddress), START (Port), END Element
            if (AlternativeSECCType->BSSID_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BSSID, string); next=89

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(AlternativeSECCType->BSSID.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, AlternativeSECCType->BSSID.charactersLen, AlternativeSECCType->BSSID.characters, iso20_wpt_BSSID_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 89;
                                }
                            }
                        }
                    }
                }
            }
            else if (AlternativeSECCType->IPAddress_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (IPAddress, string); next=90

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(AlternativeSECCType->IPAddress.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, AlternativeSECCType->IPAddress.charactersLen, AlternativeSECCType->IPAddress.characters, iso20_wpt_IPAddress_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 90;
                                }
                            }
                        }
                    }
                }
            }
            else if (AlternativeSECCType->Port_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Port, unsignedInt); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, AlternativeSECCType->Port);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 89:
            // Grammar: ID=89; read/write bits=2; START (IPAddress), START (Port), END Element
            if (AlternativeSECCType->IPAddress_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (IPAddress, string); next=90

                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // string should not be found in table, so add 2
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(AlternativeSECCType->IPAddress.charactersLen + 2));
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_characters(stream, AlternativeSECCType->IPAddress.charactersLen, AlternativeSECCType->IPAddress.characters, iso20_wpt_IPAddress_CHARACTER_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 90;
                                }
                            }
                        }
                    }
                }
            }
            else if (AlternativeSECCType->Port_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Port, unsignedInt); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, AlternativeSECCType->Port);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 90:
            // Grammar: ID=90; read/write bits=2; START (Port), END Element
            if (AlternativeSECCType->Port_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Port, unsignedInt); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, AlternativeSECCType->Port);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}LF_ReceiverSetupData; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_ReceiverDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: NumberOfReceivers, unsignedByte (1, 1); RxSpecData, WPT_TxRxSpecDataType (2, 255);
static int encode_iso20_wpt_WPT_LF_ReceiverDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_ReceiverDataType* WPT_LF_ReceiverDataType) {
    int grammar_id = 91;
    int done = 0;
    int error = 0;
    uint16_t RxSpecData_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 91:
            // Grammar: ID=91; read/write bits=1; START (NumberOfReceivers)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedShort); next=92
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 8, WPT_LF_ReceiverDataType->NumberOfReceivers);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 92;
                        }
                    }
                }
            }
            break;
        case 92:
            // Grammar: ID=92; read/write bits=2; START (RxSpecData), END Element
            if (RxSpecData_currentIndex < WPT_LF_ReceiverDataType->RxSpecData.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_TxRxSpecDataType); next=93
                    error = encode_iso20_wpt_WPT_TxRxSpecDataType(stream, &WPT_LF_ReceiverDataType->RxSpecData.array[RxSpecData_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 93;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 93:
            // Grammar: ID=93; read/write bits=1; LOOP (RxSpecData)
            if (RxSpecData_currentIndex < WPT_LF_ReceiverDataType->RxSpecData.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: LOOP (WPT_TxRxSpecDataType); next=3
                    error = encode_iso20_wpt_WPT_TxRxSpecDataType(stream, &WPT_LF_ReceiverDataType->RxSpecData.array[RxSpecData_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 3;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_LF_DataPackage; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_DataPackageType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PackageIndex, unsignedByte (1, 1); LF_TxData, WPT_LF_TxDataListType (0, 1); LF_RxData, WPT_LF_RxDataListType (0, 1);
static int encode_iso20_wpt_WPT_LF_DataPackageType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_DataPackageType* WPT_LF_DataPackageType) {
    int grammar_id = 94;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 94:
            // Grammar: ID=94; read/write bits=1; START (PackageIndex)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedShort); next=95
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 8, WPT_LF_DataPackageType->PackageIndex);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 95;
                        }
                    }
                }
            }
            break;
        case 95:
            // Grammar: ID=95; read/write bits=2; START (LF_TxData), START (LF_RxData)
            if (WPT_LF_DataPackageType->LF_TxData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_TxData, WPT_LF_TxDataListType); next=2
                    error = encode_iso20_wpt_WPT_LF_TxDataListType(stream, &WPT_LF_DataPackageType->LF_TxData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_RxData, WPT_LF_RxDataListType); next=2
                    error = encode_iso20_wpt_WPT_LF_RxDataListType(stream, &WPT_LF_DataPackageType->LF_RxData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}EnergyCosts; type={urn:iso:std:iso:15118:-20:CommonTypes}DetailedCostType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Amount, RationalNumberType (1, 1); CostPerUnit, RationalNumberType (1, 1);
static int encode_iso20_wpt_DetailedCostType(exi_bitstream_t* stream, const struct iso20_wpt_DetailedCostType* DetailedCostType) {
    int grammar_id = 96;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 96:
            // Grammar: ID=96; read/write bits=1; START (Amount)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=97
                error = encode_iso20_wpt_RationalNumberType(stream, &DetailedCostType->Amount);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 97;
                }
            }
            break;
        case 97:
            // Grammar: ID=97; read/write bits=1; START (CostPerUnit)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=2
                error = encode_iso20_wpt_RationalNumberType(stream, &DetailedCostType->CostPerUnit);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Signature; type={http://www.w3.org/2000/09/xmldsig#}SignatureType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignedInfo, SignedInfoType (1, 1); SignatureValue, SignatureValueType (1, 1); KeyInfo, KeyInfoType (0, 1); Object, ObjectType (0, 1);
static int encode_iso20_wpt_SignatureType(exi_bitstream_t* stream, const struct iso20_wpt_SignatureType* SignatureType) {
    int grammar_id = 98;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 98:
            // Grammar: ID=98; read/write bits=2; START (Id), START (SignedInfo)
            if (SignatureType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=99

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignatureType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, SignatureType->Id.charactersLen, SignatureType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 99;
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SignedInfo, SignedInfoType); next=100
                    error = encode_iso20_wpt_SignedInfoType(stream, &SignatureType->SignedInfo);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 100;
                    }
                }
            }
            break;
        case 99:
            // Grammar: ID=99; read/write bits=1; START (SignedInfo)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (SignedInfoType); next=100
                error = encode_iso20_wpt_SignedInfoType(stream, &SignatureType->SignedInfo);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 100;
                }
            }
            break;
        case 100:
            // Grammar: ID=100; read/write bits=1; START (SignatureValue)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=101
                error = encode_iso20_wpt_SignatureValueType(stream, &SignatureType->SignatureValue);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 101;
                }
            }
            break;
        case 101:
            // Grammar: ID=101; read/write bits=2; START (KeyInfo), START (Object), END Element
            if (SignatureType->KeyInfo_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (KeyInfo, KeyInfoType); next=103
                    error = encode_iso20_wpt_KeyInfoType(stream, &SignatureType->KeyInfo);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 103;
                    }
                }
            }
            else if (SignatureType->Object_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Object, ObjectType); next=102
                    error = encode_iso20_wpt_ObjectType(stream, &SignatureType->Object);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 102;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 102:
            // Grammar: ID=102; read/write bits=2; START (Object), END Element
            if (1 == 0)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Object, ObjectType); next=2
                    error = encode_iso20_wpt_ObjectType(stream, &SignatureType->Object);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 103:
            // Grammar: ID=103; read/write bits=2; START (Object), END Element
            if (SignatureType->Object_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Object, ObjectType); next=104
                    error = encode_iso20_wpt_ObjectType(stream, &SignatureType->Object);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 104;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 104:
            // Grammar: ID=104; read/write bits=2; START (Object), END Element
            if (1 == 0)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Object, ObjectType); next=2
                    error = encode_iso20_wpt_ObjectType(stream, &SignatureType->Object);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts; type={urn:iso:std:iso:15118:-20:CommonTypes}DetailedTaxType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TaxRuleID, numericIDType (1, 1); Amount, RationalNumberType (1, 1);
static int encode_iso20_wpt_DetailedTaxType(exi_bitstream_t* stream, const struct iso20_wpt_DetailedTaxType* DetailedTaxType) {
    int grammar_id = 105;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 105:
            // Grammar: ID=105; read/write bits=1; START (TaxRuleID)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=106
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_32(stream, DetailedTaxType->TaxRuleID);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 106;
                        }
                    }
                }
            }
            break;
        case 106:
            // Grammar: ID=106; read/write bits=1; START (Amount)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=2
                error = encode_iso20_wpt_RationalNumberType(stream, &DetailedTaxType->Amount);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}Header; type={urn:iso:std:iso:15118:-20:CommonTypes}MessageHeaderType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SessionID, sessionIDType (1, 1); TimeStamp, unsignedLong (1, 1); Signature, SignatureType (0, 1);
static int encode_iso20_wpt_MessageHeaderType(exi_bitstream_t* stream, const struct iso20_wpt_MessageHeaderType* MessageHeaderType) {
    int grammar_id = 107;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 107:
            // Grammar: ID=107; read/write bits=1; START (SessionID)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (hexBinary); next=108
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)MessageHeaderType->SessionID.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, MessageHeaderType->SessionID.bytesLen, MessageHeaderType->SessionID.bytes, iso20_wpt_sessionIDType_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 108;
                            }
                        }
                    }
                }
            }
            break;
        case 108:
            // Grammar: ID=108; read/write bits=1; START (TimeStamp)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (nonNegativeInteger); next=109
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_64(stream, MessageHeaderType->TimeStamp);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 109;
                        }
                    }
                }
            }
            break;
        case 109:
            // Grammar: ID=109; read/write bits=2; START (Signature), END Element
            if (MessageHeaderType->Signature_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Signature, SignatureType); next=2
                    error = encode_iso20_wpt_SignatureType(stream, &MessageHeaderType->Signature);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureProperty; type={http://www.w3.org/2000/09/xmldsig#}SignaturePropertyType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); Target, anyURI (1, 1); ANY, anyType (0, 1);
static int encode_iso20_wpt_SignaturePropertyType(exi_bitstream_t* stream, const struct iso20_wpt_SignaturePropertyType* SignaturePropertyType) {
    int grammar_id = 110;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 110:
            // Grammar: ID=110; read/write bits=2; START (Id), START (Target)
            if (SignaturePropertyType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=111

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignaturePropertyType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, SignaturePropertyType->Id.charactersLen, SignaturePropertyType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 111;
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Target, anyURI); next=112

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignaturePropertyType->Target.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, SignaturePropertyType->Target.charactersLen, SignaturePropertyType->Target.characters, iso20_wpt_Target_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 112;
                        }
                    }
                }
            }
            break;
        case 111:
            // Grammar: ID=111; read/write bits=1; START (Target)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (anyURI); next=112

                // string should not be found in table, so add 2
                error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignaturePropertyType->Target.charactersLen + 2));
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_characters(stream, SignaturePropertyType->Target.charactersLen, SignaturePropertyType->Target.characters, iso20_wpt_Target_CHARACTER_SIZE);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 112;
                    }
                }
            }
            break;
        case 112:
            // Grammar: ID=112; read/write bits=1; START (ANY)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (base64Binary); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)SignaturePropertyType->ANY.bytesLen);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bytes(stream, SignaturePropertyType->ANY.bytesLen, SignaturePropertyType->ANY.bytes, iso20_wpt_anyType_BYTES_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}DisplayParameters; type={urn:iso:std:iso:15118:-20:CommonTypes}DisplayParametersType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PresentSOC, percentValueType (0, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); MaximumSOC, percentValueType (0, 1); RemainingTimeToMinimumSOC, unsignedInt (0, 1); RemainingTimeToTargetSOC, unsignedInt (0, 1); RemainingTimeToMaximumSOC, unsignedInt (0, 1); ChargingComplete, boolean (0, 1); BatteryEnergyCapacity, RationalNumberType (0, 1); InletHot, boolean (0, 1);
static int encode_iso20_wpt_DisplayParametersType(exi_bitstream_t* stream, const struct iso20_wpt_DisplayParametersType* DisplayParametersType) {
    int grammar_id = 113;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 113:
            // Grammar: ID=113; read/write bits=4; START (PresentSOC), START (MinimumSOC), START (TargetSOC), START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->PresentSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PresentSOC, byte); next=114
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->PresentSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 114;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->MinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MinimumSOC, byte); next=115
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->MinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 115;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->TargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TargetSOC, byte); next=116
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->TargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 116;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->MaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MaximumSOC, byte); next=117
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->MaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 117;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMinimumSOC, unsignedLong); next=118
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 118;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToTargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToTargetSOC, unsignedLong); next=119
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToTargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 119;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 7);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 8);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 9);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 10);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 114:
            // Grammar: ID=114; read/write bits=4; START (MinimumSOC), START (TargetSOC), START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->MinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MinimumSOC, byte); next=115
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->MinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 115;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->TargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TargetSOC, byte); next=116
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->TargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 116;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->MaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MaximumSOC, byte); next=117
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->MaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 117;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMinimumSOC, unsignedLong); next=118
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 118;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToTargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToTargetSOC, unsignedLong); next=119
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToTargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 119;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 7);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 8);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 9);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 115:
            // Grammar: ID=115; read/write bits=4; START (TargetSOC), START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->TargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TargetSOC, byte); next=116
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->TargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 116;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->MaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MaximumSOC, byte); next=117
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->MaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 117;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMinimumSOC, unsignedLong); next=118
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 118;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToTargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToTargetSOC, unsignedLong); next=119
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToTargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 119;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 7);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 8);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 116:
            // Grammar: ID=116; read/write bits=4; START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->MaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MaximumSOC, byte); next=117
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 7, (uint32_t)DisplayParametersType->MaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 117;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMinimumSOC, unsignedLong); next=118
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 118;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToTargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToTargetSOC, unsignedLong); next=119
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToTargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 119;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 4, 7);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 117:
            // Grammar: ID=117; read/write bits=3; START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->RemainingTimeToMinimumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMinimumSOC, unsignedLong); next=118
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMinimumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 118;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToTargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToTargetSOC, unsignedLong); next=119
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToTargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 119;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 118:
            // Grammar: ID=118; read/write bits=3; START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->RemainingTimeToTargetSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToTargetSOC, unsignedLong); next=119
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToTargetSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 119;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 119:
            // Grammar: ID=119; read/write bits=3; START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->RemainingTimeToMaximumSOC_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (RemainingTimeToMaximumSOC, unsignedLong); next=120
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, DisplayParametersType->RemainingTimeToMaximumSOC);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 120;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 120:
            // Grammar: ID=120; read/write bits=3; START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->ChargingComplete_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ChargingComplete, boolean); next=121
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->ChargingComplete);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 121;
                            }
                        }
                    }
                }
            }
            else if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 121:
            // Grammar: ID=121; read/write bits=2; START (BatteryEnergyCapacity), START (InletHot), END Element
            if (DisplayParametersType->BatteryEnergyCapacity_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BatteryEnergyCapacity, RationalNumberType); next=122
                    error = encode_iso20_wpt_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 122;
                    }
                }
            }
            else if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 122:
            // Grammar: ID=122; read/write bits=2; START (InletHot), END Element
            if (DisplayParametersType->InletHot_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (InletHot, boolean); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, DisplayParametersType->InletHot);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}EVDeviceFinePositioningMethodList; type={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningMethodListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: WPT_FinePositioningMethod, WPT_FinePositioningMethodType (1, 8);
static int encode_iso20_wpt_WPT_FinePositioningMethodListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningMethodListType* WPT_FinePositioningMethodListType) {
    int grammar_id = 123;
    int done = 0;
    int error = 0;
    uint16_t WPT_FinePositioningMethod_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 123:
            // Grammar: ID=123; read/write bits=1; START (WPT_FinePositioningMethod)
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=124
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 124;
                            }
                        }
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 124:
            // Grammar: ID=124; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=125
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 125;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 125:
            // Grammar: ID=125; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=126
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 126;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 126:
            // Grammar: ID=126; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=127
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 127;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 127:
            // Grammar: ID=127; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=128
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 128;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 128:
            // Grammar: ID=128; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=129
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 129;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 129:
            // Grammar: ID=129; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=130
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 130;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 130:
            // Grammar: ID=130; read/write bits=2; START (WPT_FinePositioningMethod), END Element
            if (WPT_FinePositioningMethod_currentIndex < WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_FinePositioningMethodListType->WPT_FinePositioningMethod.array[WPT_FinePositioningMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}EVSEStatus; type={urn:iso:std:iso:15118:-20:CommonTypes}EVSEStatusType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: NotificationMaxDelay, unsignedShort (1, 1); EVSENotification, evseNotificationType (1, 1);
static int encode_iso20_wpt_EVSEStatusType(exi_bitstream_t* stream, const struct iso20_wpt_EVSEStatusType* EVSEStatusType) {
    int grammar_id = 131;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 131:
            // Grammar: ID=131; read/write bits=1; START (NotificationMaxDelay)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=132
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, EVSEStatusType->NotificationMaxDelay);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 132;
                        }
                    }
                }
            }
            break;
        case 132:
            // Grammar: ID=132; read/write bits=1; START (EVSENotification)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=2
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 3, EVSEStatusType->EVSENotification);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 2;
                        }
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}EVDevicePairingMethodList; type={urn:iso:std:iso:15118:-20:WPT}WPT_PairingMethodListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: WPT_PairingMethod, WPT_PairingMethodType (1, 8);
static int encode_iso20_wpt_WPT_PairingMethodListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_PairingMethodListType* WPT_PairingMethodListType) {
    int grammar_id = 133;
    int done = 0;
    int error = 0;
    uint16_t WPT_PairingMethod_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 133:
            // Grammar: ID=133; read/write bits=1; START (WPT_PairingMethod)
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=134
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 134;
                            }
                        }
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 134:
            // Grammar: ID=134; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=135
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 135;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 135:
            // Grammar: ID=135; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=136
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 136;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 136:
            // Grammar: ID=136; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=137
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 137;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 137:
            // Grammar: ID=137; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=138
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 138;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 138:
            // Grammar: ID=138; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=139
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 139;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 139:
            // Grammar: ID=139; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=140
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 140;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 140:
            // Grammar: ID=140; read/write bits=2; START (WPT_PairingMethod), END Element
            if (WPT_PairingMethod_currentIndex < WPT_PairingMethodListType->WPT_PairingMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_PairingMethodListType->WPT_PairingMethod.array[WPT_PairingMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}MeterInfo; type={urn:iso:std:iso:15118:-20:CommonTypes}MeterInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: MeterID, meterIDType (1, 1); ChargedEnergyReadingWh, unsignedLong (1, 1); BPT_DischargedEnergyReadingWh, unsignedLong (0, 1); CapacitiveEnergyReadingVARh, unsignedLong (0, 1); BPT_InductiveEnergyReadingVARh, unsignedLong (0, 1); MeterSignature, meterSignatureType (0, 1); MeterStatus, short (0, 1); MeterTimestamp, unsignedLong (0, 1);
static int encode_iso20_wpt_MeterInfoType(exi_bitstream_t* stream, const struct iso20_wpt_MeterInfoType* MeterInfoType) {
    int grammar_id = 141;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 141:
            // Grammar: ID=141; read/write bits=1; START (MeterID)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=142

                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(MeterInfoType->MeterID.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, MeterInfoType->MeterID.charactersLen, MeterInfoType->MeterID.characters, iso20_wpt_MeterID_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 142;
                            }
                        }
                    }
                }
            }
            break;
        case 142:
            // Grammar: ID=142; read/write bits=1; START (ChargedEnergyReadingWh)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (nonNegativeInteger); next=143
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->ChargedEnergyReadingWh);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 143;
                        }
                    }
                }
            }
            break;
        case 143:
            // Grammar: ID=143; read/write bits=3; START (BPT_DischargedEnergyReadingWh), START (CapacitiveEnergyReadingVARh), START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            if (MeterInfoType->BPT_DischargedEnergyReadingWh_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BPT_DischargedEnergyReadingWh, nonNegativeInteger); next=144
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->BPT_DischargedEnergyReadingWh);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 144;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->CapacitiveEnergyReadingVARh_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (CapacitiveEnergyReadingVARh, nonNegativeInteger); next=145
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->CapacitiveEnergyReadingVARh);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 145;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BPT_InductiveEnergyReadingVARh, nonNegativeInteger); next=146
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->BPT_InductiveEnergyReadingVARh);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 146;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterSignature_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterSignature, base64Binary); next=147
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)MeterInfoType->MeterSignature.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, MeterInfoType->MeterSignature.bytesLen, MeterInfoType->MeterSignature.bytes, iso20_wpt_meterSignatureType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 147;
                                }
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterStatus_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterStatus, int); next=148
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_integer_16(stream, MeterInfoType->MeterStatus);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 148;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterTimestamp_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterTimestamp, nonNegativeInteger); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->MeterTimestamp);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 6);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 144:
            // Grammar: ID=144; read/write bits=3; START (CapacitiveEnergyReadingVARh), START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            if (MeterInfoType->CapacitiveEnergyReadingVARh_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (CapacitiveEnergyReadingVARh, nonNegativeInteger); next=145
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->CapacitiveEnergyReadingVARh);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 145;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BPT_InductiveEnergyReadingVARh, nonNegativeInteger); next=146
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->BPT_InductiveEnergyReadingVARh);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 146;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterSignature_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterSignature, base64Binary); next=147
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)MeterInfoType->MeterSignature.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, MeterInfoType->MeterSignature.bytesLen, MeterInfoType->MeterSignature.bytes, iso20_wpt_meterSignatureType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 147;
                                }
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterStatus_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterStatus, int); next=148
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_integer_16(stream, MeterInfoType->MeterStatus);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 148;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterTimestamp_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterTimestamp, nonNegativeInteger); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->MeterTimestamp);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 145:
            // Grammar: ID=145; read/write bits=3; START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            if (MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (BPT_InductiveEnergyReadingVARh, nonNegativeInteger); next=146
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->BPT_InductiveEnergyReadingVARh);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 146;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterSignature_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterSignature, base64Binary); next=147
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)MeterInfoType->MeterSignature.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, MeterInfoType->MeterSignature.bytesLen, MeterInfoType->MeterSignature.bytes, iso20_wpt_meterSignatureType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 147;
                                }
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterStatus_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterStatus, int); next=148
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_integer_16(stream, MeterInfoType->MeterStatus);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 148;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterTimestamp_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterTimestamp, nonNegativeInteger); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->MeterTimestamp);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 146:
            // Grammar: ID=146; read/write bits=3; START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            if (MeterInfoType->MeterSignature_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterSignature, base64Binary); next=147
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)MeterInfoType->MeterSignature.bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, MeterInfoType->MeterSignature.bytesLen, MeterInfoType->MeterSignature.bytes, iso20_wpt_meterSignatureType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 147;
                                }
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterStatus_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterStatus, int); next=148
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_integer_16(stream, MeterInfoType->MeterStatus);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 148;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterTimestamp_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterTimestamp, nonNegativeInteger); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->MeterTimestamp);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 147:
            // Grammar: ID=147; read/write bits=2; START (MeterStatus), START (MeterTimestamp), END Element
            if (MeterInfoType->MeterStatus_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterStatus, int); next=148
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_integer_16(stream, MeterInfoType->MeterStatus);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 148;
                            }
                        }
                    }
                }
            }
            else if (MeterInfoType->MeterTimestamp_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterTimestamp, nonNegativeInteger); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->MeterTimestamp);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 148:
            // Grammar: ID=148; read/write bits=2; START (MeterTimestamp), END Element
            if (MeterInfoType->MeterTimestamp_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterTimestamp, nonNegativeInteger); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_64(stream, MeterInfoType->MeterTimestamp);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}EVDeviceAlignmentCheckMethodList; type={urn:iso:std:iso:15118:-20:WPT}WPT_AlignmentCheckMethodListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: WPT_AlignmentCheckMethod, WPT_AlignmentCheckMethodType (1, 8);
static int encode_iso20_wpt_WPT_AlignmentCheckMethodListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_AlignmentCheckMethodListType* WPT_AlignmentCheckMethodListType) {
    int grammar_id = 149;
    int done = 0;
    int error = 0;
    uint16_t WPT_AlignmentCheckMethod_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 149:
            // Grammar: ID=149; read/write bits=1; START (WPT_AlignmentCheckMethod)
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=150
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 150;
                            }
                        }
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 150:
            // Grammar: ID=150; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=151
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 151;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 151:
            // Grammar: ID=151; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=152
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 152;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 152:
            // Grammar: ID=152; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=153
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 153;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 153:
            // Grammar: ID=153; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=154
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 154;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 154:
            // Grammar: ID=154; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=155
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 155;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 155:
            // Grammar: ID=155; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=156
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 156;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 156:
            // Grammar: ID=156; read/write bits=2; START (WPT_AlignmentCheckMethod), END Element
            if (WPT_AlignmentCheckMethod_currentIndex < WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (string); next=2
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckMethodListType->WPT_AlignmentCheckMethod.array[WPT_AlignmentCheckMethod_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 2;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_LF_DataPackageList; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_DataPackageListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: NumPackages, unsignedByte (1, 1); WPT_LF_DataPackage, WPT_LF_DataPackageType (1, 1);
static int encode_iso20_wpt_WPT_LF_DataPackageListType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_DataPackageListType* WPT_LF_DataPackageListType) {
    int grammar_id = 157;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 157:
            // Grammar: ID=157; read/write bits=1; START (NumPackages)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedShort); next=158
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 8, WPT_LF_DataPackageListType->NumPackages);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 158;
                        }
                    }
                }
            }
            break;
        case 158:
            // Grammar: ID=158; read/write bits=1; START (WPT_LF_DataPackage)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_LF_DataPackageType); next=2
                error = encode_iso20_wpt_WPT_LF_DataPackageType(stream, &WPT_LF_DataPackageListType->WPT_LF_DataPackage);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}AlternativeSECCList; type={urn:iso:std:iso:15118:-20:WPT}AlternativeSECCListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: AlternativeSECC, AlternativeSECCType (1, 8);
static int encode_iso20_wpt_AlternativeSECCListType(exi_bitstream_t* stream, const struct iso20_wpt_AlternativeSECCListType* AlternativeSECCListType) {
    int grammar_id = 159;
    int done = 0;
    int error = 0;
    uint16_t AlternativeSECC_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 159:
            // Grammar: ID=159; read/write bits=1; START (AlternativeSECC)
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=160
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 160;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 160:
            // Grammar: ID=160; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=161
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 161;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 161:
            // Grammar: ID=161; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=162
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 162;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 162:
            // Grammar: ID=162; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=163
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 163;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 163:
            // Grammar: ID=163; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=164
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 164;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 164:
            // Grammar: ID=164; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=165
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 165;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 165:
            // Grammar: ID=165; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=166
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 166;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 166:
            // Grammar: ID=166; read/write bits=2; START (AlternativeSECC), END Element
            if (AlternativeSECC_currentIndex < AlternativeSECCListType->AlternativeSECC.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCType); next=2
                    error = encode_iso20_wpt_AlternativeSECCType(stream, &AlternativeSECCListType->AlternativeSECC.array[AlternativeSECC_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}Receipt; type={urn:iso:std:iso:15118:-20:CommonTypes}ReceiptType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); EnergyCosts, DetailedCostType (0, 1); OccupancyCosts, DetailedCostType (0, 1); AdditionalServicesCosts, DetailedCostType (0, 1); OverstayCosts, DetailedCostType (0, 1); TaxCosts, DetailedTaxType (0, 10);
static int encode_iso20_wpt_ReceiptType(exi_bitstream_t* stream, const struct iso20_wpt_ReceiptType* ReceiptType) {
    int grammar_id = 167;
    int done = 0;
    int error = 0;
    uint16_t TaxCosts_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 167:
            // Grammar: ID=167; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (nonNegativeInteger); next=168
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_64(stream, ReceiptType->TimeAnchor);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 168;
                        }
                    }
                }
            }
            break;
        case 168:
            // Grammar: ID=168; read/write bits=3; START (EnergyCosts), START (OccupancyCosts), START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            if (ReceiptType->EnergyCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EnergyCosts, DetailedCostType); next=178
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->EnergyCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 178;
                    }
                }
            }
            else if (ReceiptType->OccupancyCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (OccupancyCosts, DetailedCostType); next=188
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->OccupancyCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 188;
                    }
                }
            }
            else if (ReceiptType->AdditionalServicesCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AdditionalServicesCosts, DetailedCostType); next=198
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 198;
                    }
                }
            }
            else if (ReceiptType->OverstayCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (OverstayCosts, DetailedCostType); next=208
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 208;
                    }
                }
            }
            else if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=169 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 169;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 5);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 169:
            // Grammar: ID=169; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=170 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 170;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 170:
            // Grammar: ID=170; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=171 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 171;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 171:
            // Grammar: ID=171; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=172 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 172;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 172:
            // Grammar: ID=172; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=173 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 173;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 173:
            // Grammar: ID=173; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=174 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 174;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 174:
            // Grammar: ID=174; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=175 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 175;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 175:
            // Grammar: ID=175; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=176 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 176;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 176:
            // Grammar: ID=176; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=177 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 177;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 177:
            // Grammar: ID=177; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=2 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 178:
            // Grammar: ID=178; read/write bits=3; START (OccupancyCosts), START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            if (ReceiptType->OccupancyCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (OccupancyCosts, DetailedCostType); next=188
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->OccupancyCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 188;
                    }
                }
            }
            else if (ReceiptType->AdditionalServicesCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AdditionalServicesCosts, DetailedCostType); next=198
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 198;
                    }
                }
            }
            else if (ReceiptType->OverstayCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (OverstayCosts, DetailedCostType); next=208
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 208;
                    }
                }
            }
            else if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=179 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 179;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 4);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 179:
            // Grammar: ID=179; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=180 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 180;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 180:
            // Grammar: ID=180; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=181 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 181;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 181:
            // Grammar: ID=181; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=182 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 182;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 182:
            // Grammar: ID=182; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=183 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 183;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 183:
            // Grammar: ID=183; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=184 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 184;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 184:
            // Grammar: ID=184; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=185 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 185;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 185:
            // Grammar: ID=185; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=186 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 186;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 186:
            // Grammar: ID=186; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=187 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 187;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 187:
            // Grammar: ID=187; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=2 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 188:
            // Grammar: ID=188; read/write bits=3; START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            if (ReceiptType->AdditionalServicesCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AdditionalServicesCosts, DetailedCostType); next=198
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 198;
                    }
                }
            }
            else if (ReceiptType->OverstayCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (OverstayCosts, DetailedCostType); next=208
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 208;
                    }
                }
            }
            else if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=189 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 189;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 189:
            // Grammar: ID=189; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=190 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 190;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 190:
            // Grammar: ID=190; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=191 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 191;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 191:
            // Grammar: ID=191; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=192 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 192;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 192:
            // Grammar: ID=192; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=193 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 193;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 193:
            // Grammar: ID=193; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=194 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 194;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 194:
            // Grammar: ID=194; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=195 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 195;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 195:
            // Grammar: ID=195; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=196 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 196;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 196:
            // Grammar: ID=196; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=197 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 197;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 197:
            // Grammar: ID=197; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=2 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 198:
            // Grammar: ID=198; read/write bits=2; START (OverstayCosts), START (TaxCosts), END Element
            if (ReceiptType->OverstayCosts_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (OverstayCosts, DetailedCostType); next=208
                    error = encode_iso20_wpt_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 208;
                    }
                }
            }
            else if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=199 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 199;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 199:
            // Grammar: ID=199; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=200 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 200;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 200:
            // Grammar: ID=200; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=201 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 201;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 201:
            // Grammar: ID=201; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=202 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 202;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 202:
            // Grammar: ID=202; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=203 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 203;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 203:
            // Grammar: ID=203; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=204 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 204;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 204:
            // Grammar: ID=204; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=205 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 205;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 205:
            // Grammar: ID=205; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=206 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 206;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 206:
            // Grammar: ID=206; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=207 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 207;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 207:
            // Grammar: ID=207; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=2 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 208:
            // Grammar: ID=208; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=209 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 209;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 209:
            // Grammar: ID=209; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=210 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 210;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 210:
            // Grammar: ID=210; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=211 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 211;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 211:
            // Grammar: ID=211; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=212 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 212;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 212:
            // Grammar: ID=212; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=213 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 213;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 213:
            // Grammar: ID=213; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=214 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 214;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 214:
            // Grammar: ID=214; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=215 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 215;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 215:
            // Grammar: ID=215; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=216 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 216;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 216:
            // Grammar: ID=216; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=217 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 217;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 217:
            // Grammar: ID=217; read/write bits=2; START (TaxCosts), END Element
            if (TaxCosts_currentIndex < ReceiptType->TaxCosts.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TaxCosts, DetailedTaxType); next=2 (optional array)
                    error = encode_iso20_wpt_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[TaxCosts_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}LF_SystemSetupData; type={urn:iso:std:iso:15118:-20:WPT}WPT_LF_SystemSetupDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: LF_TransmitterSetupData, WPT_LF_TransmitterDataType (0, 1); LF_ReceiverSetupData, WPT_LF_ReceiverDataType (0, 1);
static int encode_iso20_wpt_WPT_LF_SystemSetupDataType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_LF_SystemSetupDataType* WPT_LF_SystemSetupDataType) {
    int grammar_id = 218;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 218:
            // Grammar: ID=218; read/write bits=2; START (LF_TransmitterSetupData), START (LF_ReceiverSetupData)
            if (WPT_LF_SystemSetupDataType->LF_TransmitterSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_TransmitterSetupData, WPT_LF_TransmitterDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_TransmitterDataType(stream, &WPT_LF_SystemSetupDataType->LF_TransmitterSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_ReceiverSetupData, WPT_LF_ReceiverDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_ReceiverDataType(stream, &WPT_LF_SystemSetupDataType->LF_ReceiverSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}EVPCPowerControlParameter; type={urn:iso:std:iso:15118:-20:WPT}WPT_EVPCPowerControlParameterType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVPCCoilCurrentRequest, RationalNumberType (1, 1); EVPCCoilCurrentInformation, RationalNumberType (1, 1); EVPCCurrentOutputInformation, RationalNumberType (1, 1); EVPCVoltageOutputInformation, RationalNumberType (1, 1);
static int encode_iso20_wpt_WPT_EVPCPowerControlParameterType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_EVPCPowerControlParameterType* WPT_EVPCPowerControlParameterType) {
    int grammar_id = 219;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 219:
            // Grammar: ID=219; read/write bits=1; START (EVPCCoilCurrentRequest)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=220
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_EVPCPowerControlParameterType->EVPCCoilCurrentRequest);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 220;
                }
            }
            break;
        case 220:
            // Grammar: ID=220; read/write bits=1; START (EVPCCoilCurrentInformation)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=221
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_EVPCPowerControlParameterType->EVPCCoilCurrentInformation);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 221;
                }
            }
            break;
        case 221:
            // Grammar: ID=221; read/write bits=1; START (EVPCCurrentOutputInformation)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=222
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_EVPCPowerControlParameterType->EVPCCurrentOutputInformation);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 222;
                }
            }
            break;
        case 222:
            // Grammar: ID=222; read/write bits=1; START (EVPCVoltageOutputInformation)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=2
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_EVPCPowerControlParameterType->EVPCVoltageOutputInformation);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}SPCPowerControlParameter; type={urn:iso:std:iso:15118:-20:WPT}WPT_SPCPowerControlParameterType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SPCPrimaryDeviceCoilCurrentInformation, RationalNumberType (1, 1);
static int encode_iso20_wpt_WPT_SPCPowerControlParameterType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_SPCPowerControlParameterType* WPT_SPCPowerControlParameterType) {
    int grammar_id = 223;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 223:
            // Grammar: ID=223; read/write bits=1; START (SPCPrimaryDeviceCoilCurrentInformation)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=2
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_SPCPowerControlParameterType->SPCPrimaryDeviceCoilCurrentInformation);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 2;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningSetupReq; type={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningSetupReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVProcessing, processingType (1, 1); EVDeviceFinePositioningMethodList, WPT_FinePositioningMethodListType (1, 1); EVDevicePairingMethodList, WPT_PairingMethodListType (1, 1); EVDeviceAlignmentCheckMethodList, WPT_AlignmentCheckMethodListType (1, 1); NaturalOffset, unsignedShort (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16); LF_SystemSetupData, WPT_LF_SystemSetupDataType (0, 1);
static int encode_iso20_wpt_WPT_FinePositioningSetupReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningSetupReqType* WPT_FinePositioningSetupReqType) {
    int grammar_id = 224;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 224:
            // Grammar: ID=224; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=225
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_FinePositioningSetupReqType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 225;
                }
            }
            break;
        case 225:
            // Grammar: ID=225; read/write bits=1; START (EVProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=226
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_FinePositioningSetupReqType->EVProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 226;
                        }
                    }
                }
            }
            break;
        case 226:
            // Grammar: ID=226; read/write bits=1; START (EVDeviceFinePositioningMethodList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_FinePositioningMethodListType); next=227
                error = encode_iso20_wpt_WPT_FinePositioningMethodListType(stream, &WPT_FinePositioningSetupReqType->EVDeviceFinePositioningMethodList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 227;
                }
            }
            break;
        case 227:
            // Grammar: ID=227; read/write bits=1; START (EVDevicePairingMethodList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_PairingMethodListType); next=228
                error = encode_iso20_wpt_WPT_PairingMethodListType(stream, &WPT_FinePositioningSetupReqType->EVDevicePairingMethodList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 228;
                }
            }
            break;
        case 228:
            // Grammar: ID=228; read/write bits=1; START (EVDeviceAlignmentCheckMethodList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_AlignmentCheckMethodListType); next=229
                error = encode_iso20_wpt_WPT_AlignmentCheckMethodListType(stream, &WPT_FinePositioningSetupReqType->EVDeviceAlignmentCheckMethodList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 229;
                }
            }
            break;
        case 229:
            // Grammar: ID=229; read/write bits=1; START (NaturalOffset)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=230
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_FinePositioningSetupReqType->NaturalOffset);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 230;
                        }
                    }
                }
            }
            break;
        case 230:
            // Grammar: ID=230; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=231 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 231;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 231:
            // Grammar: ID=231; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=232 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 232;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 232:
            // Grammar: ID=232; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=233 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 233;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 233:
            // Grammar: ID=233; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=234 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 234;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 234:
            // Grammar: ID=234; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=235 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 235;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 235:
            // Grammar: ID=235; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=236 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 236;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 236:
            // Grammar: ID=236; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=237 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 237;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 237:
            // Grammar: ID=237; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=238 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 238;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 238:
            // Grammar: ID=238; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=239 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 239;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 239:
            // Grammar: ID=239; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=240 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 240;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 240:
            // Grammar: ID=240; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=241 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 241;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 241:
            // Grammar: ID=241; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=242 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 242;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 242:
            // Grammar: ID=242; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=243 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 243;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 243:
            // Grammar: ID=243; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=244 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 244;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 244:
            // Grammar: ID=244; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=245 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 245;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 245:
            // Grammar: ID=245; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=246 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 246;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 246:
            // Grammar: ID=246; read/write bits=2; START (LF_SystemSetupData), END Element
            if (WPT_FinePositioningSetupReqType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupReqType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningSetupRes; type={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningSetupResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); PrimaryDeviceFinePositioningMethodList, WPT_FinePositioningMethodListType (1, 1); PrimaryDevicePairingMethodList, WPT_PairingMethodListType (1, 1); PrimaryDeviceAlignmentCheckMethodList, WPT_AlignmentCheckMethodListType (1, 1); NaturalOffset, unsignedShort (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16); LF_SystemSetupData, WPT_LF_SystemSetupDataType (0, 1);
static int encode_iso20_wpt_WPT_FinePositioningSetupResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningSetupResType* WPT_FinePositioningSetupResType) {
    int grammar_id = 247;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 247:
            // Grammar: ID=247; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=248
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_FinePositioningSetupResType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 248;
                }
            }
            break;
        case 248:
            // Grammar: ID=248; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=249
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 6, WPT_FinePositioningSetupResType->ResponseCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 249;
                        }
                    }
                }
            }
            break;
        case 249:
            // Grammar: ID=249; read/write bits=1; START (PrimaryDeviceFinePositioningMethodList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_FinePositioningMethodListType); next=250
                error = encode_iso20_wpt_WPT_FinePositioningMethodListType(stream, &WPT_FinePositioningSetupResType->PrimaryDeviceFinePositioningMethodList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 250;
                }
            }
            break;
        case 250:
            // Grammar: ID=250; read/write bits=1; START (PrimaryDevicePairingMethodList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_PairingMethodListType); next=251
                error = encode_iso20_wpt_WPT_PairingMethodListType(stream, &WPT_FinePositioningSetupResType->PrimaryDevicePairingMethodList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 251;
                }
            }
            break;
        case 251:
            // Grammar: ID=251; read/write bits=1; START (PrimaryDeviceAlignmentCheckMethodList)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (WPT_AlignmentCheckMethodListType); next=252
                error = encode_iso20_wpt_WPT_AlignmentCheckMethodListType(stream, &WPT_FinePositioningSetupResType->PrimaryDeviceAlignmentCheckMethodList);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 252;
                }
            }
            break;
        case 252:
            // Grammar: ID=252; read/write bits=1; START (NaturalOffset)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=253
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_FinePositioningSetupResType->NaturalOffset);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 253;
                        }
                    }
                }
            }
            break;
        case 253:
            // Grammar: ID=253; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=254 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 254;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 254:
            // Grammar: ID=254; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=255 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 255;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 255:
            // Grammar: ID=255; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=256 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 256;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 256:
            // Grammar: ID=256; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=257 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 257;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 257:
            // Grammar: ID=257; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=258 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 258;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 258:
            // Grammar: ID=258; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=259 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 259;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 259:
            // Grammar: ID=259; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=260 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 260;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 260:
            // Grammar: ID=260; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=261 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 261;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 261:
            // Grammar: ID=261; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=262 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 262;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 262:
            // Grammar: ID=262; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=263 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 263;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 263:
            // Grammar: ID=263; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=264 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 264;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 264:
            // Grammar: ID=264; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=265 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 265;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 265:
            // Grammar: ID=265; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=266 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 266;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 266:
            // Grammar: ID=266; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=267 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 267;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 267:
            // Grammar: ID=267; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=268 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 268;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 268:
            // Grammar: ID=268; read/write bits=2; START (VendorSpecificDataContainer), START (LF_SystemSetupData), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningSetupResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=269 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningSetupResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 269;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 269:
            // Grammar: ID=269; read/write bits=2; START (LF_SystemSetupData), END Element
            if (WPT_FinePositioningSetupResType->LF_SystemSetupData_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (LF_SystemSetupData, WPT_LF_SystemSetupDataType); next=2
                    error = encode_iso20_wpt_WPT_LF_SystemSetupDataType(stream, &WPT_FinePositioningSetupResType->LF_SystemSetupData);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningReq; type={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVProcessing, processingType (1, 1); EVResultCode, WPT_EVResultType (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16); WPT_LF_DataPackageList, WPT_LF_DataPackageListType (0, 1);
static int encode_iso20_wpt_WPT_FinePositioningReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningReqType* WPT_FinePositioningReqType) {
    int grammar_id = 270;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 270:
            // Grammar: ID=270; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=271
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_FinePositioningReqType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 271;
                }
            }
            break;
        case 271:
            // Grammar: ID=271; read/write bits=1; START (EVProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=272
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_FinePositioningReqType->EVProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 272;
                        }
                    }
                }
            }
            break;
        case 272:
            // Grammar: ID=272; read/write bits=1; START (EVResultCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=273
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_FinePositioningReqType->EVResultCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 273;
                        }
                    }
                }
            }
            break;
        case 273:
            // Grammar: ID=273; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=274 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 274;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 274:
            // Grammar: ID=274; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=275 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 275;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 275:
            // Grammar: ID=275; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=276 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 276;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 276:
            // Grammar: ID=276; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=277 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 277;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 277:
            // Grammar: ID=277; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=278 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 278;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 278:
            // Grammar: ID=278; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=279 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 279;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 279:
            // Grammar: ID=279; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=280 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 280;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 280:
            // Grammar: ID=280; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=281 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 281;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 281:
            // Grammar: ID=281; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=282 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 282;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 282:
            // Grammar: ID=282; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=283 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 283;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 283:
            // Grammar: ID=283; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=284 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 284;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 284:
            // Grammar: ID=284; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=285 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 285;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 285:
            // Grammar: ID=285; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=286 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 286;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 286:
            // Grammar: ID=286; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=287 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 287;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 287:
            // Grammar: ID=287; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=288 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 288;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 288:
            // Grammar: ID=288; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=289 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 289;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 289:
            // Grammar: ID=289; read/write bits=2; START (WPT_LF_DataPackageList), END Element
            if (WPT_FinePositioningReqType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningReqType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningRes; type={urn:iso:std:iso:15118:-20:WPT}WPT_FinePositioningResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEProcessing, processingType (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16); WPT_LF_DataPackageList, WPT_LF_DataPackageListType (0, 1);
static int encode_iso20_wpt_WPT_FinePositioningResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_FinePositioningResType* WPT_FinePositioningResType) {
    int grammar_id = 290;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 290:
            // Grammar: ID=290; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=291
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_FinePositioningResType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 291;
                }
            }
            break;
        case 291:
            // Grammar: ID=291; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=292
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 6, WPT_FinePositioningResType->ResponseCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 292;
                        }
                    }
                }
            }
            break;
        case 292:
            // Grammar: ID=292; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=293
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_FinePositioningResType->EVSEProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 293;
                        }
                    }
                }
            }
            break;
        case 293:
            // Grammar: ID=293; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=294 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 294;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 294:
            // Grammar: ID=294; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=295 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 295;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 295:
            // Grammar: ID=295; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=296 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 296;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 296:
            // Grammar: ID=296; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=297 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 297;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 297:
            // Grammar: ID=297; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=298 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 298;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 298:
            // Grammar: ID=298; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=299 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 299;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 299:
            // Grammar: ID=299; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=300 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 300;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 300:
            // Grammar: ID=300; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=301 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 301;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 301:
            // Grammar: ID=301; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=302 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 302;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 302:
            // Grammar: ID=302; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=303 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 303;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 303:
            // Grammar: ID=303; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=304 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 304;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 304:
            // Grammar: ID=304; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=305 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 305;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 305:
            // Grammar: ID=305; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=306 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 306;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 306:
            // Grammar: ID=306; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=307 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 307;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 307:
            // Grammar: ID=307; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=308 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 308;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 308:
            // Grammar: ID=308; read/write bits=2; START (VendorSpecificDataContainer), START (WPT_LF_DataPackageList), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_FinePositioningResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=309 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_FinePositioningResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 309;
                                }
                            }
                        }
                    }
                }
            }
            else if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 309:
            // Grammar: ID=309; read/write bits=2; START (WPT_LF_DataPackageList), END Element
            if (WPT_FinePositioningResType->WPT_LF_DataPackageList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (WPT_LF_DataPackageList, WPT_LF_DataPackageListType); next=2
                    error = encode_iso20_wpt_WPT_LF_DataPackageListType(stream, &WPT_FinePositioningResType->WPT_LF_DataPackageList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_PairingReq; type={urn:iso:std:iso:15118:-20:WPT}WPT_PairingReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVProcessing, processingType (1, 1); ObservedIDCode, numericIDType (0, 1); EVResultCode, WPT_EVResultType (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_PairingReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_PairingReqType* WPT_PairingReqType) {
    int grammar_id = 310;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 310:
            // Grammar: ID=310; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=311
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_PairingReqType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 311;
                }
            }
            break;
        case 311:
            // Grammar: ID=311; read/write bits=1; START (EVProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=312
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_PairingReqType->EVProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 312;
                        }
                    }
                }
            }
            break;
        case 312:
            // Grammar: ID=312; read/write bits=2; START (ObservedIDCode), START (EVResultCode)
            if (WPT_PairingReqType->ObservedIDCode_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ObservedIDCode, unsignedInt); next=313
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, WPT_PairingReqType->ObservedIDCode);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 313;
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVResultCode, string); next=314
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_PairingReqType->EVResultCode);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 314;
                            }
                        }
                    }
                }
            }
            break;
        case 313:
            // Grammar: ID=313; read/write bits=1; START (EVResultCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=314
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_PairingReqType->EVResultCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 314;
                        }
                    }
                }
            }
            break;
        case 314:
            // Grammar: ID=314; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=315 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 315;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 315:
            // Grammar: ID=315; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=316 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 316;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 316:
            // Grammar: ID=316; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=317 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 317;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 317:
            // Grammar: ID=317; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=318 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 318;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 318:
            // Grammar: ID=318; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=319 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 319;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 319:
            // Grammar: ID=319; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=320 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 320;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 320:
            // Grammar: ID=320; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=321 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 321;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 321:
            // Grammar: ID=321; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=322 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 322;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 322:
            // Grammar: ID=322; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=323 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 323;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 323:
            // Grammar: ID=323; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=324 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 324;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 324:
            // Grammar: ID=324; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=325 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 325;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 325:
            // Grammar: ID=325; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=326 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 326;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 326:
            // Grammar: ID=326; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=327 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 327;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 327:
            // Grammar: ID=327; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=328 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 328;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 328:
            // Grammar: ID=328; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=329 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 329;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 329:
            // Grammar: ID=329; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_PairingRes; type={urn:iso:std:iso:15118:-20:WPT}WPT_PairingResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEProcessing, processingType (1, 1); ObservedIDCode, numericIDType (0, 1); AlternativeSECCList, AlternativeSECCListType (0, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_PairingResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_PairingResType* WPT_PairingResType) {
    int grammar_id = 330;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 330:
            // Grammar: ID=330; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=331
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_PairingResType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 331;
                }
            }
            break;
        case 331:
            // Grammar: ID=331; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=332
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 6, WPT_PairingResType->ResponseCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 332;
                        }
                    }
                }
            }
            break;
        case 332:
            // Grammar: ID=332; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=333
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_PairingResType->EVSEProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 333;
                        }
                    }
                }
            }
            break;
        case 333:
            // Grammar: ID=333; read/write bits=3; START (ObservedIDCode), START (AlternativeSECCList), START (VendorSpecificDataContainer), END Element
            if (WPT_PairingResType->ObservedIDCode_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ObservedIDCode, unsignedInt); next=349
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_32(stream, WPT_PairingResType->ObservedIDCode);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 349;
                            }
                        }
                    }
                }
            }
            else if (WPT_PairingResType->AlternativeSECCList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCList, AlternativeSECCListType); next=365
                    error = encode_iso20_wpt_AlternativeSECCListType(stream, &WPT_PairingResType->AlternativeSECCList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 365;
                    }
                }
            }
            else if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=334 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 334;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 334:
            // Grammar: ID=334; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=335 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 335;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 335:
            // Grammar: ID=335; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=336 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 336;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 336:
            // Grammar: ID=336; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=337 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 337;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 337:
            // Grammar: ID=337; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=338 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 338;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 338:
            // Grammar: ID=338; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=339 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 339;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 339:
            // Grammar: ID=339; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=340 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 340;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 340:
            // Grammar: ID=340; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=341 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 341;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 341:
            // Grammar: ID=341; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=342 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 342;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 342:
            // Grammar: ID=342; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=343 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 343;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 343:
            // Grammar: ID=343; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=344 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 344;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 344:
            // Grammar: ID=344; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=345 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 345;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 345:
            // Grammar: ID=345; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=346 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 346;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 346:
            // Grammar: ID=346; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=347 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 347;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 347:
            // Grammar: ID=347; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=348 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 348;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 348:
            // Grammar: ID=348; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 349:
            // Grammar: ID=349; read/write bits=2; START (AlternativeSECCList), START (VendorSpecificDataContainer), END Element
            if (WPT_PairingResType->AlternativeSECCList_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (AlternativeSECCList, AlternativeSECCListType); next=365
                    error = encode_iso20_wpt_AlternativeSECCListType(stream, &WPT_PairingResType->AlternativeSECCList);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 365;
                    }
                }
            }
            else if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=350 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 350;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 350:
            // Grammar: ID=350; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=351 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 351;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 351:
            // Grammar: ID=351; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=352 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 352;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 352:
            // Grammar: ID=352; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=353 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 353;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 353:
            // Grammar: ID=353; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=354 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 354;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 354:
            // Grammar: ID=354; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=355 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 355;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 355:
            // Grammar: ID=355; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=356 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 356;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 356:
            // Grammar: ID=356; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=357 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 357;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 357:
            // Grammar: ID=357; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=358 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 358;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 358:
            // Grammar: ID=358; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=359 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 359;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 359:
            // Grammar: ID=359; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=360 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 360;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 360:
            // Grammar: ID=360; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=361 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 361;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 361:
            // Grammar: ID=361; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=362 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 362;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 362:
            // Grammar: ID=362; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=363 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 363;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 363:
            // Grammar: ID=363; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=364 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 364;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 364:
            // Grammar: ID=364; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 365:
            // Grammar: ID=365; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=366 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 366;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 366:
            // Grammar: ID=366; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=367 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 367;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 367:
            // Grammar: ID=367; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=368 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 368;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 368:
            // Grammar: ID=368; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=369 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 369;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 369:
            // Grammar: ID=369; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=370 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 370;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 370:
            // Grammar: ID=370; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=371 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 371;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 371:
            // Grammar: ID=371; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=372 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 372;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 372:
            // Grammar: ID=372; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=373 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 373;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 373:
            // Grammar: ID=373; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=374 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 374;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 374:
            // Grammar: ID=374; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=375 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 375;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 375:
            // Grammar: ID=375; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=376 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 376;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 376:
            // Grammar: ID=376; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=377 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 377;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 377:
            // Grammar: ID=377; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=378 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 378;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 378:
            // Grammar: ID=378; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=379 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 379;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 379:
            // Grammar: ID=379; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=380 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 380;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 380:
            // Grammar: ID=380; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_PairingResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_PairingResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeParameterDiscoveryReq; type={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeParameterDiscoveryReqType; base type=ChargeParameterDiscoveryReqType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVPCMaxReceivablePower, RationalNumberType (1, 1); SDMaxGroundClearence, unsignedShort (1, 1); SDMinGroundClearence, unsignedShort (1, 1); EVPCNaturalFrequency, RationalNumberType (1, 1); EVPCDeviceLocalControl, boolean (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_ChargeParameterDiscoveryReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeParameterDiscoveryReqType* WPT_ChargeParameterDiscoveryReqType) {
    int grammar_id = 381;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 381:
            // Grammar: ID=381; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=382
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_ChargeParameterDiscoveryReqType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 382;
                }
            }
            break;
        case 382:
            // Grammar: ID=382; read/write bits=1; START (EVPCMaxReceivablePower)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=383
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeParameterDiscoveryReqType->EVPCMaxReceivablePower);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 383;
                }
            }
            break;
        case 383:
            // Grammar: ID=383; read/write bits=1; START (SDMaxGroundClearence)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=384
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_ChargeParameterDiscoveryReqType->SDMaxGroundClearence);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 384;
                        }
                    }
                }
            }
            break;
        case 384:
            // Grammar: ID=384; read/write bits=1; START (SDMinGroundClearence)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=385
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_ChargeParameterDiscoveryReqType->SDMinGroundClearence);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 385;
                        }
                    }
                }
            }
            break;
        case 385:
            // Grammar: ID=385; read/write bits=1; START (EVPCNaturalFrequency)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=386
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeParameterDiscoveryReqType->EVPCNaturalFrequency);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 386;
                }
            }
            break;
        case 386:
            // Grammar: ID=386; read/write bits=1; START (EVPCDeviceLocalControl)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (boolean); next=387
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_bool(stream, WPT_ChargeParameterDiscoveryReqType->EVPCDeviceLocalControl);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 387;
                        }
                    }
                }
            }
            break;
        case 387:
            // Grammar: ID=387; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=388 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 388;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 388:
            // Grammar: ID=388; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=389 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 389;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 389:
            // Grammar: ID=389; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=390 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 390;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 390:
            // Grammar: ID=390; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=391 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 391;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 391:
            // Grammar: ID=391; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=392 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 392;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 392:
            // Grammar: ID=392; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=393 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 393;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 393:
            // Grammar: ID=393; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=394 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 394;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 394:
            // Grammar: ID=394; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=395 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 395;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 395:
            // Grammar: ID=395; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=396 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 396;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 396:
            // Grammar: ID=396; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=397 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 397;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 397:
            // Grammar: ID=397; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=398 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 398;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 398:
            // Grammar: ID=398; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=399 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 399;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 399:
            // Grammar: ID=399; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=400 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 400;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 400:
            // Grammar: ID=400; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=401 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 401;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 401:
            // Grammar: ID=401; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=402 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 402;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 402:
            // Grammar: ID=402; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeParameterDiscoveryRes; type={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeParameterDiscoveryResType; base type=ChargeParameterDiscoveryResType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); PDInputPowerClass, WPT_PowerClassType (1, 1); SDMinOutputPower, RationalNumberType (1, 1); SDMaxOutputPower, RationalNumberType (1, 1); SDMaxGroundClearanceSupport, unsignedShort (1, 1); SDMinGroundClearanceSupport, unsignedShort (1, 1); PDMinCoilCurrent, RationalNumberType (1, 1); PDMaxCoilCurrent, RationalNumberType (1, 1); SDManufacturerSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_ChargeParameterDiscoveryResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeParameterDiscoveryResType* WPT_ChargeParameterDiscoveryResType) {
    int grammar_id = 403;
    int done = 0;
    int error = 0;
    uint16_t SDManufacturerSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 403:
            // Grammar: ID=403; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=404
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_ChargeParameterDiscoveryResType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 404;
                }
            }
            break;
        case 404:
            // Grammar: ID=404; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=405
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 6, WPT_ChargeParameterDiscoveryResType->ResponseCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 405;
                        }
                    }
                }
            }
            break;
        case 405:
            // Grammar: ID=405; read/write bits=1; START (PDInputPowerClass)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=406
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_ChargeParameterDiscoveryResType->PDInputPowerClass);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 406;
                        }
                    }
                }
            }
            break;
        case 406:
            // Grammar: ID=406; read/write bits=1; START (SDMinOutputPower)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=407
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeParameterDiscoveryResType->SDMinOutputPower);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 407;
                }
            }
            break;
        case 407:
            // Grammar: ID=407; read/write bits=1; START (SDMaxOutputPower)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=408
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeParameterDiscoveryResType->SDMaxOutputPower);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 408;
                }
            }
            break;
        case 408:
            // Grammar: ID=408; read/write bits=1; START (SDMaxGroundClearanceSupport)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=409
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_ChargeParameterDiscoveryResType->SDMaxGroundClearanceSupport);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 409;
                        }
                    }
                }
            }
            break;
        case 409:
            // Grammar: ID=409; read/write bits=1; START (SDMinGroundClearanceSupport)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (unsignedInt); next=410
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_uint_16(stream, WPT_ChargeParameterDiscoveryResType->SDMinGroundClearanceSupport);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 410;
                        }
                    }
                }
            }
            break;
        case 410:
            // Grammar: ID=410; read/write bits=1; START (PDMinCoilCurrent)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=411
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeParameterDiscoveryResType->PDMinCoilCurrent);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 411;
                }
            }
            break;
        case 411:
            // Grammar: ID=411; read/write bits=1; START (PDMaxCoilCurrent)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=412
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeParameterDiscoveryResType->PDMaxCoilCurrent);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 412;
                }
            }
            break;
        case 412:
            // Grammar: ID=412; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=413 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 413;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 413:
            // Grammar: ID=413; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=414 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 414;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 414:
            // Grammar: ID=414; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=415 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 415;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 415:
            // Grammar: ID=415; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=416 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 416;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 416:
            // Grammar: ID=416; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=417 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 417;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 417:
            // Grammar: ID=417; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=418 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 418;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 418:
            // Grammar: ID=418; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=419 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 419;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 419:
            // Grammar: ID=419; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=420 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 420;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 420:
            // Grammar: ID=420; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=421 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 421;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 421:
            // Grammar: ID=421; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=422 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 422;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 422:
            // Grammar: ID=422; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=423 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 423;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 423:
            // Grammar: ID=423; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=424 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 424;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 424:
            // Grammar: ID=424; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=425 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 425;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 425:
            // Grammar: ID=425; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=426 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 426;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 426:
            // Grammar: ID=426; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=427 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 427;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 427:
            // Grammar: ID=427; read/write bits=2; START (SDManufacturerSpecificDataContainer), END Element
            if (SDManufacturerSpecificDataContainer_currentIndex < WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeParameterDiscoveryResType->SDManufacturerSpecificDataContainer.array[SDManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                SDManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_AlignmentCheckReq; type={urn:iso:std:iso:15118:-20:WPT}WPT_AlignmentCheckReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVProcessing, processingType (1, 1); TargetCoilCurrent, RationalNumberType (0, 1); EVResultCode, WPT_EVResultType (1, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_AlignmentCheckReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_AlignmentCheckReqType* WPT_AlignmentCheckReqType) {
    int grammar_id = 428;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 428:
            // Grammar: ID=428; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=429
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_AlignmentCheckReqType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 429;
                }
            }
            break;
        case 429:
            // Grammar: ID=429; read/write bits=1; START (EVProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=430
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckReqType->EVProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 430;
                        }
                    }
                }
            }
            break;
        case 430:
            // Grammar: ID=430; read/write bits=2; START (TargetCoilCurrent), START (EVResultCode)
            if (WPT_AlignmentCheckReqType->TargetCoilCurrent_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (TargetCoilCurrent, RationalNumberType); next=431
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_AlignmentCheckReqType->TargetCoilCurrent);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 431;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVResultCode, string); next=432
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckReqType->EVResultCode);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 432;
                            }
                        }
                    }
                }
            }
            break;
        case 431:
            // Grammar: ID=431; read/write bits=1; START (EVResultCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=432
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckReqType->EVResultCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 432;
                        }
                    }
                }
            }
            break;
        case 432:
            // Grammar: ID=432; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=433 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 433;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 433:
            // Grammar: ID=433; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=434 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 434;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 434:
            // Grammar: ID=434; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=435 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 435;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 435:
            // Grammar: ID=435; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=436 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 436;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 436:
            // Grammar: ID=436; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=437 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 437;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 437:
            // Grammar: ID=437; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=438 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 438;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 438:
            // Grammar: ID=438; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=439 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 439;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 439:
            // Grammar: ID=439; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=440 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 440;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 440:
            // Grammar: ID=440; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=441 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 441;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 441:
            // Grammar: ID=441; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=442 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 442;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 442:
            // Grammar: ID=442; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=443 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 443;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 443:
            // Grammar: ID=443; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=444 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 444;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 444:
            // Grammar: ID=444; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=445 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 445;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 445:
            // Grammar: ID=445; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=446 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 446;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 446:
            // Grammar: ID=446; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=447 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 447;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 447:
            // Grammar: ID=447; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckReqType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckReqType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_AlignmentCheckRes; type={urn:iso:std:iso:15118:-20:WPT}WPT_AlignmentCheckResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEProcessing, processingType (1, 1); PowerTransmitted, RationalNumberType (0, 1); SupplyDeviceCurrent, RationalNumberType (0, 1); VendorSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_AlignmentCheckResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_AlignmentCheckResType* WPT_AlignmentCheckResType) {
    int grammar_id = 448;
    int done = 0;
    int error = 0;
    uint16_t VendorSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 448:
            // Grammar: ID=448; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=449
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_AlignmentCheckResType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 449;
                }
            }
            break;
        case 449:
            // Grammar: ID=449; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=450
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 6, WPT_AlignmentCheckResType->ResponseCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 450;
                        }
                    }
                }
            }
            break;
        case 450:
            // Grammar: ID=450; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=451
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_AlignmentCheckResType->EVSEProcessing);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 451;
                        }
                    }
                }
            }
            break;
        case 451:
            // Grammar: ID=451; read/write bits=3; START (PowerTransmitted), START (SupplyDeviceCurrent), START (VendorSpecificDataContainer), END Element
            if (WPT_AlignmentCheckResType->PowerTransmitted_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (PowerTransmitted, RationalNumberType); next=467
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_AlignmentCheckResType->PowerTransmitted);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 467;
                    }
                }
            }
            else if (WPT_AlignmentCheckResType->SupplyDeviceCurrent_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SupplyDeviceCurrent, RationalNumberType); next=483
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_AlignmentCheckResType->SupplyDeviceCurrent);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 483;
                    }
                }
            }
            else if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=452 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 452;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 452:
            // Grammar: ID=452; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=453 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 453;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 453:
            // Grammar: ID=453; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=454 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 454;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 454:
            // Grammar: ID=454; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=455 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 455;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 455:
            // Grammar: ID=455; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=456 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 456;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 456:
            // Grammar: ID=456; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=457 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 457;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 457:
            // Grammar: ID=457; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=458 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 458;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 458:
            // Grammar: ID=458; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=459 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 459;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 459:
            // Grammar: ID=459; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=460 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 460;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 460:
            // Grammar: ID=460; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=461 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 461;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 461:
            // Grammar: ID=461; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=462 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 462;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 462:
            // Grammar: ID=462; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=463 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 463;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 463:
            // Grammar: ID=463; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=464 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 464;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 464:
            // Grammar: ID=464; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=465 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 465;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 465:
            // Grammar: ID=465; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=466 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 466;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 466:
            // Grammar: ID=466; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 467:
            // Grammar: ID=467; read/write bits=2; START (SupplyDeviceCurrent), START (VendorSpecificDataContainer), END Element
            if (WPT_AlignmentCheckResType->SupplyDeviceCurrent_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SupplyDeviceCurrent, RationalNumberType); next=483
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_AlignmentCheckResType->SupplyDeviceCurrent);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 483;
                    }
                }
            }
            else if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=468 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 468;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 468:
            // Grammar: ID=468; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=469 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 469;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 469:
            // Grammar: ID=469; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=470 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 470;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 470:
            // Grammar: ID=470; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=471 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 471;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 471:
            // Grammar: ID=471; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=472 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 472;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 472:
            // Grammar: ID=472; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=473 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 473;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 473:
            // Grammar: ID=473; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=474 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 474;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 474:
            // Grammar: ID=474; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=475 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 475;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 475:
            // Grammar: ID=475; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=476 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 476;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 476:
            // Grammar: ID=476; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=477 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 477;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 477:
            // Grammar: ID=477; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=478 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 478;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 478:
            // Grammar: ID=478; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=479 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 479;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 479:
            // Grammar: ID=479; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=480 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 480;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 480:
            // Grammar: ID=480; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=481 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 481;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 481:
            // Grammar: ID=481; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=482 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 482;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 482:
            // Grammar: ID=482; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 483:
            // Grammar: ID=483; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=484 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 484;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 484:
            // Grammar: ID=484; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=485 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 485;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 485:
            // Grammar: ID=485; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=486 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 486;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 486:
            // Grammar: ID=486; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=487 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 487;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 487:
            // Grammar: ID=487; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=488 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 488;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 488:
            // Grammar: ID=488; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=489 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 489;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 489:
            // Grammar: ID=489; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=490 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 490;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 490:
            // Grammar: ID=490; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=491 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 491;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 491:
            // Grammar: ID=491; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=492 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 492;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 492:
            // Grammar: ID=492; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=493 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 493;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 493:
            // Grammar: ID=493; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=494 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 494;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 494:
            // Grammar: ID=494; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=495 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 495;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 495:
            // Grammar: ID=495; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=496 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 496;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 496:
            // Grammar: ID=496; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=497 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 497;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 497:
            // Grammar: ID=497; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=498 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 498;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 498:
            // Grammar: ID=498; read/write bits=2; START (VendorSpecificDataContainer), END Element
            if (VendorSpecificDataContainer_currentIndex < WPT_AlignmentCheckResType->VendorSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (VendorSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytesLen, WPT_AlignmentCheckResType->VendorSpecificDataContainer.array[VendorSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                VendorSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeLoopReq; type={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeLoopReqType; base type=ChargeLoopReqType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); DisplayParameters, DisplayParametersType (0, 1); MeterInfoRequested, boolean (1, 1); EVPCPowerRequest, RationalNumberType (1, 1); EVPCPowerOutput, RationalNumberType (1, 1); EVPCChargeDiagnostics, WPT_EVPCChargeDiagnosticsType (1, 1); EVPCOperatingFrequency, RationalNumberType (0, 1); EVPCPowerControlParameter, WPT_EVPCPowerControlParameterType (0, 1); ManufacturerSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_ChargeLoopReqType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeLoopReqType* WPT_ChargeLoopReqType) {
    int grammar_id = 499;
    int done = 0;
    int error = 0;
    uint16_t ManufacturerSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 499:
            // Grammar: ID=499; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=500
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_ChargeLoopReqType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 500;
                }
            }
            break;
        case 500:
            // Grammar: ID=500; read/write bits=2; START (DisplayParameters), START (MeterInfoRequested)
            if (WPT_ChargeLoopReqType->DisplayParameters_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (DisplayParameters, DisplayParametersType); next=501
                    error = encode_iso20_wpt_DisplayParametersType(stream, &WPT_ChargeLoopReqType->DisplayParameters);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 501;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterInfoRequested, boolean); next=502
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_bool(stream, WPT_ChargeLoopReqType->MeterInfoRequested);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            // encode END Element
                            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                grammar_id = 502;
                            }
                        }
                    }
                }
            }
            break;
        case 501:
            // Grammar: ID=501; read/write bits=1; START (MeterInfoRequested)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (boolean); next=502
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_bool(stream, WPT_ChargeLoopReqType->MeterInfoRequested);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 502;
                        }
                    }
                }
            }
            break;
        case 502:
            // Grammar: ID=502; read/write bits=1; START (EVPCPowerRequest)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=503
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopReqType->EVPCPowerRequest);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 503;
                }
            }
            break;
        case 503:
            // Grammar: ID=503; read/write bits=1; START (EVPCPowerOutput)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=504
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopReqType->EVPCPowerOutput);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 504;
                }
            }
            break;
        case 504:
            // Grammar: ID=504; read/write bits=1; START (EVPCChargeDiagnostics)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=505
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, WPT_ChargeLoopReqType->EVPCChargeDiagnostics);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 505;
                        }
                    }
                }
            }
            break;
        case 505:
            // Grammar: ID=505; read/write bits=3; START (EVPCOperatingFrequency), START (EVPCPowerControlParameter), START (ManufacturerSpecificDataContainer), END Element
            if (WPT_ChargeLoopReqType->EVPCOperatingFrequency_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVPCOperatingFrequency, RationalNumberType); next=521
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopReqType->EVPCOperatingFrequency);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 521;
                    }
                }
            }
            else if (WPT_ChargeLoopReqType->EVPCPowerControlParameter_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVPCPowerControlParameter, WPT_EVPCPowerControlParameterType); next=537
                    error = encode_iso20_wpt_WPT_EVPCPowerControlParameterType(stream, &WPT_ChargeLoopReqType->EVPCPowerControlParameter);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 537;
                    }
                }
            }
            else if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=506 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 506;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 506:
            // Grammar: ID=506; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=507 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 507;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 507:
            // Grammar: ID=507; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=508 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 508;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 508:
            // Grammar: ID=508; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=509 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 509;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 509:
            // Grammar: ID=509; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=510 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 510;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 510:
            // Grammar: ID=510; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=511 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 511;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 511:
            // Grammar: ID=511; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=512 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 512;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 512:
            // Grammar: ID=512; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=513 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 513;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 513:
            // Grammar: ID=513; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=514 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 514;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 514:
            // Grammar: ID=514; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=515 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 515;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 515:
            // Grammar: ID=515; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=516 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 516;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 516:
            // Grammar: ID=516; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=517 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 517;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 517:
            // Grammar: ID=517; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=518 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 518;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 518:
            // Grammar: ID=518; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=519 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 519;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 519:
            // Grammar: ID=519; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=520 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 520;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 520:
            // Grammar: ID=520; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 521:
            // Grammar: ID=521; read/write bits=2; START (EVPCPowerControlParameter), START (ManufacturerSpecificDataContainer), END Element
            if (WPT_ChargeLoopReqType->EVPCPowerControlParameter_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVPCPowerControlParameter, WPT_EVPCPowerControlParameterType); next=537
                    error = encode_iso20_wpt_WPT_EVPCPowerControlParameterType(stream, &WPT_ChargeLoopReqType->EVPCPowerControlParameter);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 537;
                    }
                }
            }
            else if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=522 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 522;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 522:
            // Grammar: ID=522; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=523 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 523;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 523:
            // Grammar: ID=523; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=524 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 524;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 524:
            // Grammar: ID=524; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=525 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 525;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 525:
            // Grammar: ID=525; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=526 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 526;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 526:
            // Grammar: ID=526; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=527 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 527;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 527:
            // Grammar: ID=527; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=528 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 528;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 528:
            // Grammar: ID=528; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=529 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 529;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 529:
            // Grammar: ID=529; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=530 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 530;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 530:
            // Grammar: ID=530; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=531 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 531;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 531:
            // Grammar: ID=531; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=532 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 532;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 532:
            // Grammar: ID=532; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=533 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 533;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 533:
            // Grammar: ID=533; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=534 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 534;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 534:
            // Grammar: ID=534; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=535 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 535;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 535:
            // Grammar: ID=535; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=536 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 536;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 536:
            // Grammar: ID=536; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 537:
            // Grammar: ID=537; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=538 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 538;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 538:
            // Grammar: ID=538; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=539 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 539;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 539:
            // Grammar: ID=539; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=540 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 540;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 540:
            // Grammar: ID=540; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=541 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 541;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 541:
            // Grammar: ID=541; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=542 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 542;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 542:
            // Grammar: ID=542; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=543 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 543;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 543:
            // Grammar: ID=543; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=544 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 544;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 544:
            // Grammar: ID=544; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=545 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 545;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 545:
            // Grammar: ID=545; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=546 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 546;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 546:
            // Grammar: ID=546; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=547 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 547;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 547:
            // Grammar: ID=547; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=548 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 548;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 548:
            // Grammar: ID=548; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=549 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 549;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 549:
            // Grammar: ID=549; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=550 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 550;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 550:
            // Grammar: ID=550; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=551 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 551;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 551:
            // Grammar: ID=551; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=552 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 552;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 552:
            // Grammar: ID=552; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopReqType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeLoopRes; type={urn:iso:std:iso:15118:-20:WPT}WPT_ChargeLoopResType; base type=ChargeLoopResType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEStatus, EVSEStatusType (0, 1); MeterInfo, MeterInfoType (0, 1); Receipt, ReceiptType (0, 1); EVPCPowerRequest, RationalNumberType (1, 1); SDPowerInput, RationalNumberType (0, 1); SPCMaxOutputPowerLimit, RationalNumberType (1, 1); SPCMinOutputPowerLimit, RationalNumberType (1, 1); SPCChargeDiagnostics, WPT_SPCChargeDiagnosticsType (1, 1); SPCOperatingFrequency, RationalNumberType (0, 1); SPCPowerControlParameter, WPT_SPCPowerControlParameterType (0, 1); ManufacturerSpecificDataContainer, WPT_DataContainerType (0, 16);
static int encode_iso20_wpt_WPT_ChargeLoopResType(exi_bitstream_t* stream, const struct iso20_wpt_WPT_ChargeLoopResType* WPT_ChargeLoopResType) {
    int grammar_id = 553;
    int done = 0;
    int error = 0;
    uint16_t ManufacturerSpecificDataContainer_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 553:
            // Grammar: ID=553; read/write bits=1; START (Header)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (MessageHeaderType); next=554
                error = encode_iso20_wpt_MessageHeaderType(stream, &WPT_ChargeLoopResType->Header);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 554;
                }
            }
            break;
        case 554:
            // Grammar: ID=554; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=555
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 6, WPT_ChargeLoopResType->ResponseCode);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 555;
                        }
                    }
                }
            }
            break;
        case 555:
            // Grammar: ID=555; read/write bits=3; START (EVSEStatus), START (MeterInfo), START (Receipt), START (EVPCPowerRequest)
            if (WPT_ChargeLoopResType->EVSEStatus_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVSEStatus, EVSEStatusType); next=556
                    error = encode_iso20_wpt_EVSEStatusType(stream, &WPT_ChargeLoopResType->EVSEStatus);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 556;
                    }
                }
            }
            else if (WPT_ChargeLoopResType->MeterInfo_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterInfo, MeterInfoType); next=557
                    error = encode_iso20_wpt_MeterInfoType(stream, &WPT_ChargeLoopResType->MeterInfo);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 557;
                    }
                }
            }
            else if (WPT_ChargeLoopResType->Receipt_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Receipt, ReceiptType); next=558
                    error = encode_iso20_wpt_ReceiptType(stream, &WPT_ChargeLoopResType->Receipt);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 558;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVPCPowerRequest, RationalNumberType); next=559
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->EVPCPowerRequest);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 559;
                    }
                }
            }
            break;
        case 556:
            // Grammar: ID=556; read/write bits=2; START (MeterInfo), START (Receipt), START (EVPCPowerRequest)
            if (WPT_ChargeLoopResType->MeterInfo_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (MeterInfo, MeterInfoType); next=557
                    error = encode_iso20_wpt_MeterInfoType(stream, &WPT_ChargeLoopResType->MeterInfo);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 557;
                    }
                }
            }
            else if (WPT_ChargeLoopResType->Receipt_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Receipt, ReceiptType); next=558
                    error = encode_iso20_wpt_ReceiptType(stream, &WPT_ChargeLoopResType->Receipt);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 558;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVPCPowerRequest, RationalNumberType); next=559
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->EVPCPowerRequest);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 559;
                    }
                }
            }
            break;
        case 557:
            // Grammar: ID=557; read/write bits=2; START (Receipt), START (EVPCPowerRequest)
            if (WPT_ChargeLoopResType->Receipt_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Receipt, ReceiptType); next=558
                    error = encode_iso20_wpt_ReceiptType(stream, &WPT_ChargeLoopResType->Receipt);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 558;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (EVPCPowerRequest, RationalNumberType); next=559
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->EVPCPowerRequest);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 559;
                    }
                }
            }
            break;
        case 558:
            // Grammar: ID=558; read/write bits=1; START (EVPCPowerRequest)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=559
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->EVPCPowerRequest);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 559;
                }
            }
            break;
        case 559:
            // Grammar: ID=559; read/write bits=2; START (SDPowerInput), START (SPCMaxOutputPowerLimit)
            if (WPT_ChargeLoopResType->SDPowerInput_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SDPowerInput, RationalNumberType); next=560
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->SDPowerInput);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 560;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SPCMaxOutputPowerLimit, RationalNumberType); next=561
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->SPCMaxOutputPowerLimit);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 561;
                    }
                }
            }
            break;
        case 560:
            // Grammar: ID=560; read/write bits=1; START (SPCMaxOutputPowerLimit)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=561
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->SPCMaxOutputPowerLimit);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 561;
                }
            }
            break;
        case 561:
            // Grammar: ID=561; read/write bits=1; START (SPCMinOutputPowerLimit)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (RationalNumberType); next=562
                error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->SPCMinOutputPowerLimit);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 562;
                }
            }
            break;
        case 562:
            // Grammar: ID=562; read/write bits=1; START (SPCChargeDiagnostics)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (string); next=563
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 3, WPT_ChargeLoopResType->SPCChargeDiagnostics);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // encode END Element
                        error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 563;
                        }
                    }
                }
            }
            break;
        case 563:
            // Grammar: ID=563; read/write bits=3; START (SPCOperatingFrequency), START (SPCPowerControlParameter), START (ManufacturerSpecificDataContainer), END Element
            if (WPT_ChargeLoopResType->SPCOperatingFrequency_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SPCOperatingFrequency, RationalNumberType); next=579
                    error = encode_iso20_wpt_RationalNumberType(stream, &WPT_ChargeLoopResType->SPCOperatingFrequency);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 579;
                    }
                }
            }
            else if (WPT_ChargeLoopResType->SPCPowerControlParameter_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SPCPowerControlParameter, WPT_SPCPowerControlParameterType); next=595
                    error = encode_iso20_wpt_WPT_SPCPowerControlParameterType(stream, &WPT_ChargeLoopResType->SPCPowerControlParameter);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 595;
                    }
                }
            }
            else if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=564 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 564;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 3, 3);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 564:
            // Grammar: ID=564; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=565 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 565;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 565:
            // Grammar: ID=565; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=566 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 566;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 566:
            // Grammar: ID=566; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=567 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 567;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 567:
            // Grammar: ID=567; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=568 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 568;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 568:
            // Grammar: ID=568; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=569 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 569;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 569:
            // Grammar: ID=569; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=570 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 570;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 570:
            // Grammar: ID=570; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=571 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 571;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 571:
            // Grammar: ID=571; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=572 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 572;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 572:
            // Grammar: ID=572; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=573 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 573;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 573:
            // Grammar: ID=573; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=574 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 574;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 574:
            // Grammar: ID=574; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=575 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 575;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 575:
            // Grammar: ID=575; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=576 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 576;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 576:
            // Grammar: ID=576; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=577 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 577;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 577:
            // Grammar: ID=577; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=578 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 578;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 578:
            // Grammar: ID=578; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 579:
            // Grammar: ID=579; read/write bits=2; START (SPCPowerControlParameter), START (ManufacturerSpecificDataContainer), END Element
            if (WPT_ChargeLoopResType->SPCPowerControlParameter_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SPCPowerControlParameter, WPT_SPCPowerControlParameterType); next=595
                    error = encode_iso20_wpt_WPT_SPCPowerControlParameterType(stream, &WPT_ChargeLoopResType->SPCPowerControlParameter);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 595;
                    }
                }
            }
            else if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=580 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 580;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 2);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 580:
            // Grammar: ID=580; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=581 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 581;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 581:
            // Grammar: ID=581; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=582 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 582;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 582:
            // Grammar: ID=582; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=583 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 583;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 583:
            // Grammar: ID=583; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=584 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 584;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 584:
            // Grammar: ID=584; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=585 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 585;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 585:
            // Grammar: ID=585; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=586 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 586;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 586:
            // Grammar: ID=586; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=587 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 587;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 587:
            // Grammar: ID=587; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=588 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 588;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 588:
            // Grammar: ID=588; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=589 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 589;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 589:
            // Grammar: ID=589; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=590 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 590;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 590:
            // Grammar: ID=590; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=591 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 591;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 591:
            // Grammar: ID=591; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=592 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 592;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 592:
            // Grammar: ID=592; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=593 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 593;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 593:
            // Grammar: ID=593; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=594 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 594;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 594:
            // Grammar: ID=594; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 595:
            // Grammar: ID=595; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=596 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 596;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 596:
            // Grammar: ID=596; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=597 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 597;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 597:
            // Grammar: ID=597; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=598 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 598;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 598:
            // Grammar: ID=598; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=599 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 599;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 599:
            // Grammar: ID=599; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=600 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 600;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 600:
            // Grammar: ID=600; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=601 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 601;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 601:
            // Grammar: ID=601; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=602 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 602;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 602:
            // Grammar: ID=602; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=603 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 603;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 603:
            // Grammar: ID=603; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=604 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 604;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 604:
            // Grammar: ID=604; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=605 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 605;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 605:
            // Grammar: ID=605; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=606 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 606;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 606:
            // Grammar: ID=606; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=607 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 607;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 607:
            // Grammar: ID=607; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=608 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 608;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 608:
            // Grammar: ID=608; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=609 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 609;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 609:
            // Grammar: ID=609; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=610 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 610;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 610:
            // Grammar: ID=610; read/write bits=2; START (ManufacturerSpecificDataContainer), END Element
            if (ManufacturerSpecificDataContainer_currentIndex < WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ManufacturerSpecificDataContainer, base64Binary); next=2 (optional array)
                    error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_uint_16(stream, (uint16_t)WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            error = exi_basetypes_encoder_bytes(stream, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytesLen, WPT_ChargeLoopResType->ManufacturerSpecificDataContainer.array[ManufacturerSpecificDataContainer_currentIndex].bytes, iso20_wpt_WPT_DataContainerType_BYTES_SIZE);
                            if (error == EXI_ERROR__NO_ERROR)
                            {
                                ManufacturerSpecificDataContainer_currentIndex++;
                                // encode END Element
                                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                                if (error == EXI_ERROR__NO_ERROR)
                                {
                                    grammar_id = 2;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlMode; type={urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int encode_iso20_wpt_CLReqControlModeType(exi_bitstream_t* stream, const struct iso20_wpt_CLReqControlModeType* CLReqControlModeType) {
    // Element has no particles, so the function just encodes END Element
    (void)CLReqControlModeType;

    int error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}CLResControlMode; type={urn:iso:std:iso:15118:-20:CommonTypes}CLResControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int encode_iso20_wpt_CLResControlModeType(exi_bitstream_t* stream, const struct iso20_wpt_CLResControlModeType* CLResControlModeType) {
    // Element has no particles, so the function just encodes END Element
    (void)CLResControlModeType;

    int error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);

    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Manifest; type={http://www.w3.org/2000/09/xmldsig#}ManifestType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Reference, ReferenceType (1, 4);
static int encode_iso20_wpt_ManifestType(exi_bitstream_t* stream, const struct iso20_wpt_ManifestType* ManifestType) {
    int grammar_id = 611;
    int done = 0;
    int error = 0;
    uint16_t Reference_currentIndex = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 611:
            // Grammar: ID=611; read/write bits=2; START (Id), START (Reference)
            if (ManifestType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=616

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(ManifestType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, ManifestType->Id.charactersLen, ManifestType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 616;
                        }
                    }
                }
            }
            else
            {
                if (Reference_currentIndex < ManifestType->Reference.arrayLen)
                {
                    error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        // Event: START (ReferenceType); next=612
                        error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 612;
                        }
                    }
                }
            }
            break;
        case 612:
            // Grammar: ID=612; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=613
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 613;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 613:
            // Grammar: ID=613; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=614
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 614;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 614:
            // Grammar: ID=614; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=615
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 615;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 615:
            // Grammar: ID=615; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=2
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 616:
            // Grammar: ID=616; read/write bits=1; START (Reference)
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=617
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 617;
                    }
                }
            }
            else
            {
                error = EXI_ERROR__UNKNOWN_EVENT_CODE;
            }
            break;
        case 617:
            // Grammar: ID=617; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=618
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 618;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 618:
            // Grammar: ID=618; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=619
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 619;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 619:
            // Grammar: ID=619; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=620
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 620;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 620:
            // Grammar: ID=620; read/write bits=2; START (Reference), END Element
            if (Reference_currentIndex < ManifestType->Reference.arrayLen)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (ReferenceType); next=2
                    error = encode_iso20_wpt_ReferenceType(stream, &ManifestType->Reference.array[Reference_currentIndex++]);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureProperties; type={http://www.w3.org/2000/09/xmldsig#}SignaturePropertiesType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignatureProperty, SignaturePropertyType (1, 1);
static int encode_iso20_wpt_SignaturePropertiesType(exi_bitstream_t* stream, const struct iso20_wpt_SignaturePropertiesType* SignaturePropertiesType) {
    int grammar_id = 621;
    int done = 0;
    int error = 0;

    while(!done)
    {
        switch(grammar_id)
        {
        case 621:
            // Grammar: ID=621; read/write bits=2; START (Id), START (SignatureProperty)
            if (SignaturePropertiesType->Id_isUsed == 1u)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (Id, NCName); next=623

                    // string should not be found in table, so add 2
                    error = exi_basetypes_encoder_uint_16(stream, (uint16_t)(SignaturePropertiesType->Id.charactersLen + 2));
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        error = exi_basetypes_encoder_characters(stream, SignaturePropertiesType->Id.charactersLen, SignaturePropertiesType->Id.characters, iso20_wpt_Id_CHARACTER_SIZE);
                        if (error == EXI_ERROR__NO_ERROR)
                        {
                            grammar_id = 623;
                        }
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SignatureProperty, SignaturePropertyType); next=622
                    error = encode_iso20_wpt_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 622;
                    }
                }
            }
            break;
        case 622:
            // Grammar: ID=622; read/write bits=2; START (SignatureProperty), END Element
            if (1 == 0)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SignatureProperty, SignaturePropertyType); next=2
                    error = encode_iso20_wpt_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 623:
            // Grammar: ID=623; read/write bits=1; START (SignatureProperty)
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: START (SignaturePropertyType); next=624
                error = encode_iso20_wpt_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    grammar_id = 624;
                }
            }
            break;
        case 624:
            // Grammar: ID=624; read/write bits=2; START (SignatureProperty), END Element
            if (1 == 0)
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 0);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: START (SignatureProperty, SignaturePropertyType); next=2
                    error = encode_iso20_wpt_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty);
                    if (error == EXI_ERROR__NO_ERROR)
                    {
                        grammar_id = 2;
                    }
                }
            }
            else
            {
                error = exi_basetypes_encoder_nbit_uint(stream, 2, 1);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_encoder_nbit_uint(stream, 1, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                // Event: END Element; next=3
                done = 1;
                grammar_id = 3;
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}


// main function for encoding
int encode_iso20_wpt_exiDocument(exi_bitstream_t* stream, struct iso20_wpt_exiDocument* exiDoc)
{
    int error = exi_header_write(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        if (exiDoc->CLReqControlMode_isUsed == 1)
        {
            // encode event 0
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 0);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_CLReqControlModeType(stream, &exiDoc->CLReqControlMode);
            }
        }
        else if (exiDoc->CLResControlMode_isUsed == 1)
        {
            // encode event 1
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 1);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_CLResControlModeType(stream, &exiDoc->CLResControlMode);
            }
        }
        else if (exiDoc->CanonicalizationMethod_isUsed == 1)
        {
            // encode event 2
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 2);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_CanonicalizationMethodType(stream, &exiDoc->CanonicalizationMethod);
            }
        }
        else if (exiDoc->DSAKeyValue_isUsed == 1)
        {
            // encode event 3
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 3);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_DSAKeyValueType(stream, &exiDoc->DSAKeyValue);
            }
        }
        else if (exiDoc->DigestMethod_isUsed == 1)
        {
            // encode event 4
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 4);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_DigestMethodType(stream, &exiDoc->DigestMethod);
            }
        }
        // simple type! encode_iso20_wpt_DigestValue;
        else if (exiDoc->KeyInfo_isUsed == 1)
        {
            // encode event 6
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 6);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_KeyInfoType(stream, &exiDoc->KeyInfo);
            }
        }
        // simple type! encode_iso20_wpt_KeyName;
        else if (exiDoc->KeyValue_isUsed == 1)
        {
            // encode event 8
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 8);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_KeyValueType(stream, &exiDoc->KeyValue);
            }
        }
        else if (exiDoc->Manifest_isUsed == 1)
        {
            // encode event 9
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 9);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_ManifestType(stream, &exiDoc->Manifest);
            }
        }
        // simple type! encode_iso20_wpt_MgmtData;
        else if (exiDoc->Object_isUsed == 1)
        {
            // encode event 11
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 11);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_ObjectType(stream, &exiDoc->Object);
            }
        }
        else if (exiDoc->PGPData_isUsed == 1)
        {
            // encode event 12
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 12);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_PGPDataType(stream, &exiDoc->PGPData);
            }
        }
        else if (exiDoc->RSAKeyValue_isUsed == 1)
        {
            // encode event 13
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 13);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_RSAKeyValueType(stream, &exiDoc->RSAKeyValue);
            }
        }
        else if (exiDoc->Reference_isUsed == 1)
        {
            // encode event 14
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 14);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_ReferenceType(stream, &exiDoc->Reference);
            }
        }
        else if (exiDoc->RetrievalMethod_isUsed == 1)
        {
            // encode event 15
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 15);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_RetrievalMethodType(stream, &exiDoc->RetrievalMethod);
            }
        }
        else if (exiDoc->SPKIData_isUsed == 1)
        {
            // encode event 16
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 16);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SPKIDataType(stream, &exiDoc->SPKIData);
            }
        }
        else if (exiDoc->SignatureMethod_isUsed == 1)
        {
            // encode event 17
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 17);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SignatureMethodType(stream, &exiDoc->SignatureMethod);
            }
        }
        else if (exiDoc->SignatureProperties_isUsed == 1)
        {
            // encode event 18
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 18);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SignaturePropertiesType(stream, &exiDoc->SignatureProperties);
            }
        }
        else if (exiDoc->SignatureProperty_isUsed == 1)
        {
            // encode event 19
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 19);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SignaturePropertyType(stream, &exiDoc->SignatureProperty);
            }
        }
        else if (exiDoc->Signature_isUsed == 1)
        {
            // encode event 20
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 20);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SignatureType(stream, &exiDoc->Signature);
            }
        }
        else if (exiDoc->SignatureValue_isUsed == 1)
        {
            // encode event 21
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 21);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SignatureValueType(stream, &exiDoc->SignatureValue);
            }
        }
        else if (exiDoc->SignedInfo_isUsed == 1)
        {
            // encode event 22
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 22);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_SignedInfoType(stream, &exiDoc->SignedInfo);
            }
        }
        else if (exiDoc->Transform_isUsed == 1)
        {
            // encode event 23
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 23);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_TransformType(stream, &exiDoc->Transform);
            }
        }
        else if (exiDoc->Transforms_isUsed == 1)
        {
            // encode event 24
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 24);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_TransformsType(stream, &exiDoc->Transforms);
            }
        }
        else if (exiDoc->WPT_AlignmentCheckReq_isUsed == 1)
        {
            // encode event 25
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 25);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_AlignmentCheckReqType(stream, &exiDoc->WPT_AlignmentCheckReq);
            }
        }
        else if (exiDoc->WPT_AlignmentCheckRes_isUsed == 1)
        {
            // encode event 26
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 26);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_AlignmentCheckResType(stream, &exiDoc->WPT_AlignmentCheckRes);
            }
        }
        else if (exiDoc->WPT_ChargeLoopReq_isUsed == 1)
        {
            // encode event 27
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 27);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_ChargeLoopReqType(stream, &exiDoc->WPT_ChargeLoopReq);
            }
        }
        else if (exiDoc->WPT_ChargeLoopRes_isUsed == 1)
        {
            // encode event 28
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 28);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_ChargeLoopResType(stream, &exiDoc->WPT_ChargeLoopRes);
            }
        }
        else if (exiDoc->WPT_ChargeParameterDiscoveryReq_isUsed == 1)
        {
            // encode event 29
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 29);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_ChargeParameterDiscoveryReqType(stream, &exiDoc->WPT_ChargeParameterDiscoveryReq);
            }
        }
        else if (exiDoc->WPT_ChargeParameterDiscoveryRes_isUsed == 1)
        {
            // encode event 30
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 30);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_ChargeParameterDiscoveryResType(stream, &exiDoc->WPT_ChargeParameterDiscoveryRes);
            }
        }
        else if (exiDoc->WPT_FinePositioningReq_isUsed == 1)
        {
            // encode event 31
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 31);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_FinePositioningReqType(stream, &exiDoc->WPT_FinePositioningReq);
            }
        }
        else if (exiDoc->WPT_FinePositioningRes_isUsed == 1)
        {
            // encode event 32
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 32);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_FinePositioningResType(stream, &exiDoc->WPT_FinePositioningRes);
            }
        }
        else if (exiDoc->WPT_FinePositioningSetupReq_isUsed == 1)
        {
            // encode event 33
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 33);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_FinePositioningSetupReqType(stream, &exiDoc->WPT_FinePositioningSetupReq);
            }
        }
        else if (exiDoc->WPT_FinePositioningSetupRes_isUsed == 1)
        {
            // encode event 34
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 34);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_FinePositioningSetupResType(stream, &exiDoc->WPT_FinePositioningSetupRes);
            }
        }
        else if (exiDoc->WPT_PairingReq_isUsed == 1)
        {
            // encode event 35
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 35);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_PairingReqType(stream, &exiDoc->WPT_PairingReq);
            }
        }
        else if (exiDoc->WPT_PairingRes_isUsed == 1)
        {
            // encode event 36
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 36);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_WPT_PairingResType(stream, &exiDoc->WPT_PairingRes);
            }
        }
        else if (exiDoc->X509Data_isUsed == 1)
        {
            // encode event 37
            error = exi_basetypes_encoder_nbit_uint(stream, 6, 37);
            if (error == EXI_ERROR__NO_ERROR)
            {
                error = encode_iso20_wpt_X509DataType(stream, &exiDoc->X509Data);
            }
        }
        else
        {
            error = EXI_ERROR__UNKNOWN_EVENT_FOR_ENCODING;
        }
    }

    return error;
}


